diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/base/allocator/partition_allocator/page_allocator_constants.h	2020-04-08 22:48:53.837918584 +0000
@@ -10,7 +10,7 @@
 #include "build/build_config.h"
 
 namespace base {
-#if defined(OS_WIN)
+#if defined(OS_WIN) || defined(ARCH_CPU_PPC64)
 static constexpr size_t kPageAllocationGranularityShift = 16;  // 64KB
 #elif defined(_MIPS_ARCH_LOONGSON)
 static constexpr size_t kPageAllocationGranularityShift = 14;  // 16KB
@@ -26,6 +26,10 @@
 
 #if defined(_MIPS_ARCH_LOONGSON)
 static constexpr size_t kSystemPageSize = 16384;
+#elif defined(ARCH_CPU_PPC64)
+// TODO: modern ppc64 can do 4k and 64k page sizes
+// for now, 64k is assumed
+static constexpr size_t kSystemPageSize = 65536;
 #else
 static constexpr size_t kSystemPageSize = 4096;
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/base/allocator/partition_allocator/partition_alloc_constants.h	2020-04-08 22:49:50.821185398 +0000
@@ -33,6 +33,8 @@
 // up against the end of a system page.
 #if defined(_MIPS_ARCH_LOONGSON)
 static const size_t kPartitionPageShift = 16;  // 64KB
+#elif defined(ARCH_CPU_PPC64)
+static const size_t kPartitionPageShift = 18;  // 256 KiB
 #else
 static const size_t kPartitionPageShift = 14;  // 16KB
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/build/toolchain/linux/BUILD.gn	2020-04-08 22:26:13.858038514 +0000
@@ -5,6 +5,14 @@
 import("//build/config/sysroot.gni")
 import("//build/toolchain/gcc_toolchain.gni")
 
+clang_toolchain("clang_ppc64") {
+  enable_linker_map = true
+  toolchain_args = {
+    current_cpu = "ppc64"
+    current_os = "linux"
+  }
+}
+
 clang_toolchain("clang_arm") {
   toolprefix = "arm-linux-gnueabihf-"
   toolchain_args = {
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/components/update_client/update_query_params.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/components/update_client/update_query_params.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/components/update_client/update_query_params.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/components/update_client/update_query_params.cc	2020-04-08 22:46:28.755076003 +0000
@@ -55,6 +55,8 @@
     "mips64el";
 #elif defined(__mips__)
     "mipsel";
+#elif defined(__powerpc64__)
+    "ppc64";
 #else
 #error "unknown arch"
 #endif
@@ -127,6 +129,8 @@
   return "mips32";
 #elif defined(ARCH_CPU_MIPS64EL)
   return "mips64";
+#elif defined(ARCH_CPU_PPC64)
+  return "ppc64";
 #else
 // NOTE: when adding new values here, please remember to update the
 // comment in the .h file about possible return values from this function.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/components/update_client/update_query_params.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/components/update_client/update_query_params.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/components/update_client/update_query_params.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/components/update_client/update_query_params.h	2020-04-08 22:46:28.755076003 +0000
@@ -45,7 +45,7 @@
   // Returns the value we use for the "nacl_arch" parameter. Note that this may
   // be different from the "arch" parameter above (e.g. one may be 32-bit and
   // the other 64-bit). Possible return values include: "x86-32", "x86-64",
-  // "arm", and "mips32".
+  // "arm", "mips32", and "ppc64".
   static const char* GetNaclArch();
 
   // Returns the current version of Chrome/Chromium.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/features.gni qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/features.gni
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/features.gni	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/features.gni	2020-04-08 22:30:42.686430863 +0000
@@ -12,6 +12,6 @@
     (is_linux || is_android) &&
     (current_cpu == "x86" || current_cpu == "x64" || current_cpu == "arm" ||
      current_cpu == "arm64" || current_cpu == "mipsel" ||
-     current_cpu == "mips64el")
+     current_cpu == "mips64el" || current_cpu == "ppc64")
 
 use_seccomp_bpf = use_seccomp_bpf || is_nacl_nonsfi
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/bpf_dsl/linux_syscall_ranges.h	2020-04-08 22:30:01.411284175 +0000
@@ -53,6 +53,13 @@
 #define MAX_PUBLIC_SYSCALL 279u
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__powerpc64__)
+
+#include <asm/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL 386u
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/bpf_dsl/seccomp_macros.h	2020-04-08 22:30:11.420107304 +0000
@@ -16,6 +16,9 @@
 #if defined(__mips__)
 // sys/user.h in eglibc misses size_t definition
 #include <stddef.h>
+#elif defined(__powerpc64__)
+// Manually define greg_t on ppc64
+typedef unsigned long long greg_t;
 #endif
 #endif
 
@@ -345,6 +348,51 @@
 #define SECCOMP_PT_PARM4(_regs) (_regs).regs[3]
 #define SECCOMP_PT_PARM5(_regs) (_regs).regs[4]
 #define SECCOMP_PT_PARM6(_regs) (_regs).regs[5]
+
+#elif defined(__powerpc64__)
+#include <asm/ptrace.h>
+
+typedef struct pt_regs regs_struct;
+
+#ifdef ARCH_CPU_LITTLE_ENDIAN
+#define SECCOMP_ARCH AUDIT_ARCH_PPC64LE
+#else
+#define SECCOMP_ARCH AUDIT_ARCH_PPC64
+#endif
+
+#define SECCOMP_REG(_ctx, _reg) ((_ctx)->uc_mcontext.regs->gpr[_reg])
+
+#define SECCOMP_RESULT(_ctx) SECCOMP_REG(_ctx, 3)
+#define SECCOMP_SYSCALL(_ctx) SECCOMP_REG(_ctx, 0)
+#define SECCOMP_IP(_ctx) (_ctx)->uc_mcontext.regs->nip
+#define SECCOMP_PARM1(_ctx) SECCOMP_REG(_ctx, 3)
+#define SECCOMP_PARM2(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_PARM3(_ctx) SECCOMP_REG(_ctx, 5)
+#define SECCOMP_PARM4(_ctx) SECCOMP_REG(_ctx, 6)
+#define SECCOMP_PARM5(_ctx) SECCOMP_REG(_ctx, 7)
+#define SECCOMP_PARM6(_ctx) SECCOMP_REG(_ctx, 8)
+
+#define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
+#define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+
+#define SECCOMP_PT_RESULT(_regs) (_regs).gpr[3]
+#define SECCOMP_PT_SYSCALL(_regs) (_regs).gpr[0]
+#define SECCOMP_PT_IP(_regs) (_regs).nip
+#define SECCOMP_PT_PARM1(_regs) (_regs).gpr[3]
+#define SECCOMP_PT_PARM2(_regs) (_regs).gpr[4]
+#define SECCOMP_PT_PARM3(_regs) (_regs).gpr[5]
+#define SECCOMP_PT_PARM4(_regs) (_regs).gpr[6]
+#define SECCOMP_PT_PARM5(_regs) (_regs).gpr[7]
+#define SECCOMP_PT_PARM6(_regs) (_regs).gpr[8]
+
 #else
 #error Unsupported target platform
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/BUILD.gn	2020-04-08 22:30:50.905464419 +0000
@@ -435,6 +435,8 @@
 
 source_set("sandbox_services_headers") {
   sources = [
+    "system_headers/ppc64_linux_syscalls.h",
+    "system_headers/ppc64_linux_ucontext.h",
     "system_headers/arm64_linux_syscalls.h",
     "system_headers/arm64_linux_ucontext.h",
     "system_headers/arm_linux_syscalls.h",
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/syscall.cc	2020-04-08 22:30:30.067914615 +0000
@@ -15,7 +15,7 @@
 namespace {
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined (ARCH_CPU_PPC64_FAMILY)
 // Number that's not currently used by any Linux kernel ABIs.
 const int kInvalidSyscallNumber = 0x351d3;
 #else
@@ -309,10 +309,54 @@
     "2:ret\n"
     ".cfi_endproc\n"
     ".size SyscallAsm, .-SyscallAsm\n"
+#elif defined(__powerpc64__)
+    ".text\n"
+    ".align 4\n"
+    ".type SyscallAsm @function\n"
+    "SyscallAsm:\n"
+    ".cfi_startproc\n"
+
+    // Check if r3 is negative
+    "cmpdi 3, 0\n"
+    "bgt 2f\n"
+
+    // Load address of 3f into r3 and return
+    "mflr 10\n"
+    "bl 1f\n"
+    "1: mflr 3\n"
+    "mtlr 10\n"
+    "addi 3, 3, 4*13\n"
+    "blr\n"
+
+    // Load arguments from array into r3-8
+    // save param 3 in r10
+    "2:\n"
+    "mr 0, 3\n"
+    "ld 3, 0(4)\n"
+    "ld 5, 16(4)\n"
+    "ld 6, 24(4)\n"
+    "ld 7, 32(4)\n"
+    "ld 8, 40(4)\n"
+    "ld 4, 8(4)\n"
+    "li 9, 0\n"
+
+    // Enter kernel
+    "sc\n"
+
+    // Magic return address
+    "3:\n"
+    // Like MIPS, ppc64 return values are always positive.
+    // Check for error in cr0.SO and negate upon error
+    "bc 4, 3, 4f\n"
+    "neg 3, 3\n"
+    "4: blr\n"
+
+    ".cfi_endproc\n"
+    ".size SyscallAsm, .-SyscallAsm\n"
 #endif
     );  // asm
 
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__powerpc64__)
 extern "C" {
 intptr_t SyscallAsm(intptr_t nr, const intptr_t args[6]);
 }
@@ -426,6 +470,8 @@
     ret = inout;
   }
 
+#elif defined(__powerpc64__)
+  intptr_t ret = SyscallAsm(nr, args);
 #else
 #error "Unimplemented architecture"
 #endif
@@ -442,8 +488,18 @@
     // needs to be changed back.
     ret_val = -ret_val;
     SECCOMP_PARM4(ctx) = 1;
-  } else
+  } else {
     SECCOMP_PARM4(ctx) = 0;
+  }
+#endif
+#if defined(__powerpc64__)
+  // Same as MIPS, need to invert ret and set error register (cr0.SO)
+  if (ret_val <= -1 && ret_val >= -4095) {
+    ret_val = -ret_val;
+    ctx->uc_mcontext.regs->ccr |= (1 << 28);
+  } else {
+    ctx->uc_mcontext.regs->ccr &= ~(1 << 28);
+  }
 #endif
   SECCOMP_RESULT(ctx) = static_cast<greg_t>(ret_val);
 }
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf/trap.cc	2020-04-08 22:44:13.171116355 +0000
@@ -225,6 +225,20 @@
       SetIsInSigHandler();
     }
 
+#if defined(__powerpc64__)
+    // On ppc64+glibc, some syscalls seem to accidentally negate the first
+    // parameter which causes checks against it to fail. For now, manually
+    // negate them back.
+    // TODO(shawn@anastas.io): investigate this issue further
+    auto nr = SECCOMP_SYSCALL(ctx);
+    if (nr == __NR_openat || nr == __NR_mkdirat || nr == __NR_faccessat || nr == __NR_readlinkat ||
+        nr == __NR_renameat || nr == __NR_renameat2 || nr == __NR_newfstatat || nr == __NR_unlinkat) {
+        if (static_cast<int>(SECCOMP_PARM1(ctx)) > 0) {
+            SECCOMP_PARM1(ctx) = -SECCOMP_PARM1(ctx);
+        }
+    }
+#endif
+
     // Copy the seccomp-specific data into a arch_seccomp_data structure. This
     // is what we are showing to TrapFnc callbacks that the system call
     // evaluator registered with the sandbox.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc	2020-04-08 22:34:01.723025891 +0000
@@ -86,7 +86,7 @@
          SyscallSets::IsNuma(sysno) ||
          SyscallSets::IsPrctl(sysno) ||
          SyscallSets::IsProcessGroupOrSession(sysno) ||
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
          SyscallSets::IsSocketCall(sysno) ||
 #endif
 #if defined(__arm__)
@@ -186,7 +186,7 @@
   }
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   if (sysno == __NR_mmap)
     return RestrictMmapFlags();
 #endif
@@ -203,7 +203,7 @@
     return RestrictPrctl();
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   if (sysno == __NR_socketpair) {
     // Only allow AF_UNIX, PF_UNIX. Crash if anything else is seen.
     static_assert(AF_UNIX == PF_UNIX,
@@ -242,7 +242,7 @@
     return Error(EPERM);
   }
 
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
   if (SyscallSets::IsSocketCall(sysno))
     return RestrictSocketcallCommand();
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc	2020-04-08 22:32:04.856768599 +0000
@@ -36,6 +36,11 @@
 #include <sys/ioctl.h>
 #endif
 
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
 #if defined(OS_ANDROID)
 
 #if !defined(F_DUPFD_CLOEXEC)
@@ -98,6 +103,15 @@
 #endif
 }
 
+inline bool IsArchitecturePPC64() {
+#if defined(__powerpc64__)
+  return true;
+#else
+  return false;
+#endif
+}
+
+
 // Ubuntu's version of glibc has a race condition in sem_post that can cause
 // it to call futex(2) with bogus op arguments. To workaround this, we need
 // to allow those futex(2) calls to fail with EINVAL, instead of crashing the
@@ -228,9 +242,11 @@
   // operator.
   // Glibc overrides the kernel's O_LARGEFILE value. Account for this.
   uint64_t kOLargeFileFlag = O_LARGEFILE;
-  if (IsArchitectureX86_64() || IsArchitectureI386() || IsArchitectureMips())
+  if (IsArchitectureX86_64() || IsArchitectureI386() || IsArchitectureMips() \
+      || IsArchitecturePPC64())
     kOLargeFileFlag = 0100000;
 
+
   const Arg<int> cmd(1);
   const Arg<long> long_arg(2);
 
@@ -244,14 +260,23 @@
               F_SETLKW,
               F_GETLK,
               F_DUPFD,
-              F_DUPFD_CLOEXEC),
-             Allow())
+              F_DUPFD_CLOEXEC
+#if defined(__powerpc64__)
+// On PPC64, F_SETLK, F_GETLK, F_SETLKW are defined as the 64-bit variants
+// but glibc will sometimes still use the 32-bit versions. Allow both.
+              ,
+              5, /* F_GETLK (32) */
+              6, /* F_SETLK (32) */
+              7  /* F_SETLKW (32) */
+#endif
+              ),
+            Allow())
       .Case(F_SETFL,
             If((long_arg & ~kAllowedMask) == 0, Allow()).Else(CrashSIGSYS()))
       .Default(CrashSIGSYS());
 }
 
-#if defined(__i386__) || defined(__mips__)
+#if defined(__i386__) || defined(__mips__) || defined(__powerpc64__)
 ResultExpr RestrictSocketcallCommand() {
   // Unfortunately, we are unable to restrict the first parameter to
   // socketpair(2). Whilst initially sounding bad, it's noteworthy that very
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.h	2020-04-08 22:32:04.856768599 +0000
@@ -48,7 +48,7 @@
 // O_NONBLOCK | O_SYNC | O_LARGEFILE | O_CLOEXEC | O_NOATIME.
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictFcntlCommands();
 
-#if defined(__i386__) || defined(__mips__)
+#if defined(__i386__) || defined(__mips__) || defined(__powerpc64__)
 // Restrict socketcall(2) to only allow socketpair(2), send(2), recv(2),
 // sendto(2), recvfrom(2), shutdown(2), sendmsg(2) and recvmsg(2).
 SANDBOX_EXPORT bpf_dsl::ResultExpr RestrictSocketcallCommand();
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc	2020-04-08 23:17:22.206584383 +0000
@@ -28,7 +28,7 @@
 bool SyscallSets::IsAllowedGettime(int sysno) {
   switch (sysno) {
     case __NR_gettimeofday:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips32__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_time:
 #endif
       return true;
@@ -38,11 +38,11 @@
     case __NR_clock_gettime:
     case __NR_clock_nanosleep:  // Could be allowed.
     case __NR_clock_settime:    // Privileged.
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_ftime:  // Obsolete.
 #endif
     case __NR_settimeofday:  // Privileged.
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_stime:
 #endif
     default:
@@ -108,7 +108,7 @@
     case __NR_faccessat:  // EPERM not a valid errno.
     case __NR_fchmodat:
     case __NR_fchownat:  // Should be called chownat ?
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__powerpc64__)
     case __NR_newfstatat:  // fstatat(). EPERM not a valid errno.
 #elif defined(__i386__) || defined(__arm__) || defined(__mips32__)
     case __NR_fstatat64:
@@ -125,7 +125,7 @@
     case __NR_memfd_create:
     case __NR_mkdirat:
     case __NR_mknodat:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_oldlstat:
     case __NR_oldstat:
 #endif
@@ -137,7 +137,7 @@
     case __NR_stat64:
 #endif
     case __NR_statfs:  // EPERM not a valid errno.
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_statfs64:
 #endif
     case __NR_symlinkat:
@@ -146,7 +146,8 @@
     case __NR_truncate64:
 #endif
     case __NR_unlinkat:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_utime:
 #endif
     case __NR_utimensat:  // New.
@@ -164,7 +165,8 @@
 #endif
       return true;
 // TODO(jln): these should be denied gracefully as well (moved below).
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_fadvise64:  // EPERM not a valid errno.
 #endif
 #if defined(__i386__)
@@ -176,11 +178,11 @@
     case __NR_fdatasync:  // EPERM not a valid errno.
     case __NR_flock:      // EPERM not a valid errno.
     case __NR_fstatfs:    // Give information about the whole filesystem.
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_fstatfs64:
 #endif
     case __NR_fsync:  // EPERM not a valid errno.
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_oldfstat:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
@@ -188,6 +190,8 @@
     case __NR_sync_file_range:  // EPERM not a valid errno.
 #elif defined(__arm__)
     case __NR_arm_sync_file_range:  // EPERM not a valid errno.
+#elif defined(__powerpc64__)
+    case __NR_sync_file_range2: // EPERM not a valid errno.
 #endif
     default:
       return false;
@@ -211,7 +215,7 @@
     case __NR_getdents:    // EPERM not a valid errno.
 #endif
     case __NR_getdents64:  // EPERM not a valid errno.
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_readdir:
 #endif
       return true;
@@ -252,7 +256,7 @@
 bool SyscallSets::IsProcessPrivilegeChange(int sysno) {
   switch (sysno) {
     case __NR_capset:
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__)
     case __NR_ioperm:  // Intel privilege.
     case __NR_iopl:    // Intel privilege.
 #endif
@@ -301,7 +305,7 @@
     case __NR_rt_sigaction:
     case __NR_rt_sigprocmask:
     case __NR_rt_sigreturn:
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_sigaction:
     case __NR_sigprocmask:
     case __NR_sigreturn:
@@ -317,7 +321,7 @@
     case __NR_signalfd:
 #endif
     case __NR_signalfd4:
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_sigpending:
     case __NR_sigsuspend:
 #endif
@@ -340,7 +344,7 @@
 #endif
     case __NR_dup3:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_shutdown:
 #endif
       return true;
@@ -372,7 +376,7 @@
     case __NR_exit_group:
     case __NR_wait4:
     case __NR_waitid:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_waitpid:
 #endif
       return true;
@@ -389,7 +393,7 @@
 #endif
     case __NR_set_tid_address:
     case __NR_unshare:
-#if !defined(__mips__) && !defined(__aarch64__)
+#if !defined(__mips__) && !defined(__aarch64__) || defined(__powerpc64__)
     case __NR_vfork:
 #endif
     default:
@@ -438,7 +442,7 @@
       return true;
     default:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_socketpair:  // We will want to inspect its argument.
 #endif
       return false;
@@ -448,7 +452,7 @@
 bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   switch (sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_accept:
     case __NR_accept4:
     case __NR_bind:
@@ -462,7 +466,7 @@
   }
 }
 
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
 // Big multiplexing system call for sockets.
 bool SyscallSets::IsSocketCall(int sysno) {
   switch (sysno) {
@@ -476,7 +480,8 @@
 }
 #endif
 
-#if defined(__x86_64__) || defined(__arm__) || defined(__mips__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
+    defined(__powerpc64__)
 bool SyscallSets::IsNetworkSocketInformation(int sysno) {
   switch (sysno) {
     case __NR_getpeername:
@@ -501,7 +506,7 @@
     case __NR_mincore:
     case __NR_mlockall:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_mmap:
 #endif
 #if defined(__i386__) || defined(__arm__) || defined(__mips32__)
@@ -528,7 +533,7 @@
 bool SyscallSets::IsAllowedGeneralIo(int sysno) {
   switch (sysno) {
     case __NR_lseek:
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR__llseek:
 #endif
 #if !defined(__aarch64__)
@@ -538,25 +543,25 @@
     case __NR_pselect6:
     case __NR_read:
     case __NR_readv:
-#if defined(__arm__) || defined(__mips32__)
+#if defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_recv:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_recvfrom:  // Could specify source.
     case __NR_recvmsg:   // Could specify source.
 #endif
-#if defined(__i386__) || defined(__x86_64__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc64__)
     case __NR_select:
 #endif
-#if defined(__i386__) || defined(__arm__) || defined(__mips__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips__) || defined(__powerpc64__)
     case __NR__newselect:
 #endif
-#if defined(__arm__) || defined(__mips32__)
+#if defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_send:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_sendmsg:  // Could specify destination.
     case __NR_sendto:   // Could specify destination.
 #endif
@@ -612,7 +617,7 @@
     case __NR_nanosleep:
       return true;
     case __NR_getpriority:
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_nice:
 #endif
     case __NR_setpriority:
@@ -623,7 +628,7 @@
 
 bool SyscallSets::IsAdminOperation(int sysno) {
   switch (sysno) {
-#if defined(__i386__) || defined(__arm__) || defined(__mips32__)
+#if defined(__i386__) || defined(__arm__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_bdflush:
 #endif
     case __NR_kexec_load:
@@ -639,7 +644,8 @@
 
 bool SyscallSets::IsKernelModule(int sysno) {
   switch (sysno) {
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_create_module:
     case __NR_get_kernel_syms:  // Should ENOSYS.
     case __NR_query_module:
@@ -671,7 +677,7 @@
     case __NR_quotactl:
     case __NR_swapoff:
     case __NR_swapon:
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_umount:
 #endif
     case __NR_umount2:
@@ -687,7 +693,7 @@
     case __NR_getcpu:
     case __NR_mbind:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_migrate_pages:
 #endif
     case __NR_move_pages:
@@ -716,13 +722,13 @@
   switch (sysno) {
     case __NR_acct:  // Privileged.
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
     case __NR_getrlimit:
 #endif
-#if defined(__i386__) || defined(__arm__)
+#if defined(__i386__) || defined(__arm__) || defined(__powerpc64__)
     case __NR_ugetrlimit:
 #endif
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_ulimit:
 #endif
     case __NR_getrusage:
@@ -756,7 +762,7 @@
 #endif
     case __NR_sysinfo:
     case __NR_uname:
-#if defined(__i386__)
+#if defined(__i386__) || defined(__powerpc64__)
     case __NR_olduname:
     case __NR_oldolduname:
 #endif
@@ -847,7 +853,7 @@
 }
 #endif
 
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
 // Big system V multiplexing system call.
 bool SyscallSets::IsSystemVIpc(int sysno) {
   switch (sysno) {
@@ -866,7 +872,7 @@
     || defined(__mips64__)
   return IsSystemVMessageQueue(sysno) || IsSystemVSemaphores(sysno) ||
          IsSystemVSharedMemory(sysno);
-#elif defined(__i386__) || defined(__mips32__)
+#elif defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
   return IsSystemVIpc(sysno);
 #endif
 }
@@ -919,7 +925,8 @@
 bool SyscallSets::IsTimer(int sysno) {
   switch (sysno) {
     case __NR_getitimer:
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
+    defined(__powerpc64__)
     case __NR_alarm:
 #endif
     case __NR_setitimer:
@@ -978,16 +985,16 @@
     case __NR_syncfs:
     case __NR_vhangup:
 // The system calls below are not implemented.
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_afs_syscall:
 #endif
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_break:
 #endif
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_getpmsg:
 #endif
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_gtty:
     case __NR_idle:
     case __NR_lock:
@@ -995,19 +1002,19 @@
     case __NR_prof:
     case __NR_profil:
 #endif
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
     case __NR_putpmsg:
 #endif
 #if defined(__x86_64__)
     case __NR_security:
 #endif
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
     case __NR_stty:
 #endif
-#if defined(__x86_64__)
+#if defined(__x86_64__) || defined(__powerpc64__)
     case __NR_tuxcall:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__powerpc64__)
     case __NR_vserver:
 #endif
       return true;
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h	2020-04-08 22:43:01.099592755 +0000
@@ -42,13 +42,13 @@
   static bool IsAllowedGetOrModifySocket(int sysno);
   static bool IsDeniedGetOrModifySocket(int sysno);
 
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
   // Big multiplexing system call for sockets.
   static bool IsSocketCall(int sysno);
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
   static bool IsNetworkSocketInformation(int sysno);
 #endif
 
@@ -85,7 +85,7 @@
   static bool IsSystemVMessageQueue(int sysno);
 #endif
 
-#if defined(__i386__) || defined(__mips32__)
+#if defined(__i386__) || defined(__mips32__) || defined(__powerpc64__)
   // Big system V multiplexing system call.
   static bool IsSystemVIpc(int sysno);
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/services/credentials.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/services/credentials.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/services/credentials.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/services/credentials.cc	2020-04-08 22:30:35.977219769 +0000
@@ -78,7 +78,7 @@
   pid_t pid = -1;
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_PPC64_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/services/syscall_wrappers.cc	2020-04-08 22:32:04.856768599 +0000
@@ -58,7 +58,7 @@
 #if defined(ARCH_CPU_X86_64)
   return syscall(__NR_clone, flags, child_stack, ptid, ctid, tls);
 #elif defined(ARCH_CPU_X86) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_PPC64_FAMILY)
   // CONFIG_CLONE_BACKWARDS defined.
   return syscall(__NR_clone, flags, child_stack, ptid, tls, ctid);
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_seccomp.h	2020-04-08 22:30:17.579383072 +0000
@@ -29,6 +29,9 @@
 #ifndef EM_AARCH64
 #define EM_AARCH64 183
 #endif
+#ifndef EM_PPC64
+#define EM_PPC64 21
+#endif
 
 #ifndef __AUDIT_ARCH_64BIT
 #define __AUDIT_ARCH_64BIT 0x80000000
@@ -54,6 +57,12 @@
 #ifndef AUDIT_ARCH_AARCH64
 #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
 #endif
+#ifndef AUDIT_ARCH_PPC64
+#define AUDIT_ARCH_PPC64 (EM_PPC64 | __AUDIT_ARCH_64BIT)
+#endif
+#ifndef AUDIT_ARCH_PPC64LE
+#define AUDIT_ARCH_PPC64LE (EM_PPC64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
+#endif
 
 // For prctl.h
 #ifndef PR_SET_SECCOMP
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_signal.h	2020-04-08 22:30:23.488688231 +0000
@@ -11,7 +11,7 @@
 // (not undefined, but defined different values and in different memory
 // layouts). So, fill the gap here.
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__powerpc64__)
 
 #define LINUX_SIGHUP 1
 #define LINUX_SIGINT 2
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_syscalls.h	2020-04-08 22:30:50.905464419 +0000
@@ -33,5 +33,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/linux_ucontext.h	2020-04-08 22:31:38.479870254 +0000
@@ -19,6 +19,8 @@
 #include "sandbox/linux/system_headers/mips64_linux_ucontext.h"
 #elif defined(__aarch64__)
 #include "sandbox/linux/system_headers/arm64_linux_ucontext.h"
+#elif defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_ucontext.h"
 #else
 #error "No support for your architecture in Android or PNaCl header"
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_syscalls.h	2020-04-08 22:30:50.905464419 +0000
@@ -0,0 +1,12 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+
+#include <asm/unistd.h>
+
+//TODO: is it necessary to redefine syscall numbers for PPC64?
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/sandbox/linux/system_headers/ppc64_linux_ucontext.h	2020-04-08 22:30:50.905464419 +0000
@@ -0,0 +1,12 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
+
+#include <sys/ucontext.h>
+
+//TODO: is it necessary to redefine ucontext on PPC64?
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/services/service_manager/sandbox/linux/bpf_renderer_policy_linux.cc	2020-04-08 22:45:03.755139574 +0000
@@ -15,6 +15,11 @@
 #include "sandbox/linux/system_headers/linux_syscalls.h"
 #include "services/service_manager/sandbox/linux/sandbox_linux.h"
 
+// On PPC64, TCGETS is defined in terms of struct termios, so we must include termios.h
+#ifdef __powerpc64__
+#include <termios.h>
+#endif
+
 #if defined(OS_CHROMEOS)
 // TODO(vignatti): replace the local definitions below with #include
 // <linux/dma-buf.h> once kernel version 4.6 becomes widely used.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/angle/src/libANGLE/Constants.h	2020-04-08 22:45:22.492920278 +0000
@@ -9,6 +9,7 @@
 #ifndef LIBANGLE_CONSTANTS_H_
 #define LIBANGLE_CONSTANTS_H_
 
+#include <cstddef>
 #include "common/platform.h"
 
 namespace gl
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/BUILD.gn	2020-04-08 23:04:02.890708774 +0000
@@ -46,6 +46,10 @@
       sources = [
         "SaveRegisters_mips64.S",
       ]
+    } else if (current_cpu == "ppc64") {
+      sources = [
+        "SaveRegisters_ppc64.S",
+      ]
     }
 
     if (current_cpu == "arm") {
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/asm/SaveRegisters_ppc64.S	2020-04-08 23:04:02.890708774 +0000
@@ -0,0 +1,60 @@
+/*
+ * typedef void (*PushAllRegistersCallback)(SafePointBarrier*, ThreadState*, intptr_t*);
+ * extern "C" void PushAllRegisters(SafePointBarrier*, ThreadState*, PushAllRegistersCallback)
+ */
+
+.type PushAllRegisters, %function
+.global PushAllRegisters
+.hidden PushAllRegisters
+PushAllRegisters:
+        // Push all callee-saves registers to get them
+        // on the stack for conservative stack scanning.
+        // Reserve space for callee-saved registers and minimal stack frame.
+        mflr 0         # r0 = LR
+        std 0,16(1)    # store LR at addr sp+16
+        stdu 1,-176(1) # grow stack by 176 bytes and store new stack top ptr to r1
+            # 3218*8 = min stack  non-volatile registers
+
+        // Save the callee-saved registers
+        std 31,168(1)  # store r31 to addr sp+168 
+        std 30,160(1)  # etc...
+        std 29,152(1)
+        std 28,144(1)
+        std 27,136(1)
+        std 26,128(1)
+        std 25,120(1)
+        std 24,112(1)
+        std 23,104(1)
+        std 22,96(1)
+        std 21,88(1)
+        std 20,80(1)
+        std 19,72(1)
+        std 18,64(1)
+        std 17,56(1)
+        std 16,48(1)
+        std 15,40(1)
+        std 14,32(1)
+        
+        // Note: the callee-saved floating point registers do not need to be
+        // copied to the stack, because fp registers never hold heap pointers
+        // and so do not need to be kept visible to the garbage collector.
+        
+        // Pass the two first arguments untouched in r3 and r4 and the
+        // stack pointer to the callback.
+
+        std 2, 24(1)   # save r2 to sp+24 addr
+        mtctr 5        # copy 3rd function arg (callback fn pointer) to CTR
+        mr 12, 5       # r12 must hold address of callback we are going to call 
+                       #  for position-idependent functions inside the callback to work
+        mr 5, 1        # set current sp (stack top) as 3rd argument for the callback
+        bctrl          # set LR to PC+4 and call the callback
+        ld 2, 24(1)    # restore r2 from sp+24 addr
+
+        // Adjust stack, restore return address and return.
+        // Note: the copied registers do not need to be reloaded here,
+        // because they were preserved by the called routine.
+        addi 1,1,176   # restore original SP by doing sp += 176
+        ld 0,16(1)     # restore original LR from addr sp+16
+        mtlr 0         # ... copy it to the actual LR
+        blr            # return to LR addr
+
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/heap_page.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/heap_page.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/heap_page.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/heap/heap_page.h	2020-04-08 22:49:59.600148315 +0000
@@ -67,11 +67,12 @@
 constexpr size_t kBlinkPagesPerRegion = 10;
 
 // TODO(nya): Replace this with something like #if ENABLE_NACL.
-#if 0
+#if defined(ARCH_CPU_PPC64)
 // NaCl's system page size is 64 KiB. This causes a problem in Oilpan's heap
 // layout because Oilpan allocates two guard pages for each Blink page (whose
 // size is kBlinkPageSize = 2^17 = 128 KiB). So we don't use guard pages in
 // NaCl.
+// The same issue holds for ppc64 systems, which use a 64k page size.
 constexpr size_t kBlinkGuardPageSize = 0;
 #else
 constexpr size_t kBlinkGuardPageSize = base::kSystemPageSize;
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/dtoa/utils.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/dtoa/utils.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/dtoa/utils.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/dtoa/utils.h	2020-04-08 22:46:22.825777699 +0000
@@ -45,7 +45,7 @@
 // disabled.)
 // On Linux,x86 89255e-22 != Div_double(89255.0/1e22)
 #if defined(_M_X64) || defined(__x86_64__) || defined(__ARMEL__) || \
-    defined(__aarch64__) || defined(__MIPSEL__)
+    defined(__aarch64__) || defined(__MIPSEL__) || defined(__powerpc64__)
 #define DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS 1
 #elif defined(_M_IX86) || defined(__i386__)
 #if defined(_WIN32)
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/boringssl/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/boringssl/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/boringssl/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/boringssl/BUILD.gn	2020-04-08 22:46:53.222180922 +0000
@@ -101,6 +101,13 @@
       } else {
         public_configs = [ ":no_asm_config" ]
       }
+    } else if (current_cpu == "ppc64") {
+      if (is_linux) {
+        # TODO: ppc64 (be) check
+        sources += crypto_sources_linux_ppc64le
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
     } else {
       public_configs = [ ":no_asm_config" ]
     }
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h	2020-04-08 22:26:44.244466132 +0000
@@ -44,6 +44,8 @@
 typedef MDRawContextARM64 RawContextCPU;
 #elif defined(__mips__)
 typedef MDRawContextMIPS RawContextCPU;
+#elif defined(__powerpc64__)
+typedef MDRawContextPPC64 RawContextCPU;
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc	2020-04-08 22:26:44.244466132 +0000
@@ -270,7 +270,42 @@
   out->float_save.fir = mcontext.fpc_eir;
 #endif
 }
-#endif  // __mips__
+
+#elif defined(__powerpc64__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+    return mcontext.gp_regs[PT_NIP];
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+    out->context_flags = MD_CONTEXT_PPC64_FULL;
+    for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+        out->gpr[i] = mcontext.gp_regs[i];
+
+    out->lr = mcontext.gp_regs[PT_LNK];
+    out->srr0 = mcontext.gp_regs[PT_NIP];
+    out->srr1 = mcontext.gp_regs[PT_MSR];
+    out->cr = mcontext.gp_regs[PT_CCR];
+    out->xer = mcontext.gp_regs[PT_XER];
+    out->ctr = mcontext.gp_regs[PT_CTR];
+    
+    for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+        out->float_save.fpregs[i] = mcontext.fp_regs[i];
+
+    out->float_save.fpscr = mcontext.fp_regs[NFPREG-1];
+
+    for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++)
+        out->vector_save.save_vr[i] = \
+            {(((uint64_t)vregs.vrregs[i][0]) << 32) 
+                          | vregs.vrregs[i][1], 
+            (((uint64_t)vregs.vrregs[i][2]) << 32)
+                         | vregs.vrregs[i][3]};
+
+    out->vrsave = vregs.vrsave;
+    out->vector_save.save_vscr = {0, vregs.vscr.vscr_word};
+    out->vector_save.save_vrvalid = 0xFFFFFFFF; 
+}
+#endif  // __powerpc64__
 
 void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
   assert(gp_regs || size);
@@ -279,6 +314,11 @@
     *gp_regs = mcontext.gregs;
   if (size)
     *size = sizeof(mcontext.gregs);
+#elif defined(__powerpc64__)
+  if (gp_regs)
+    *gp_regs = mcontext.gp_regs;
+  if (size)
+    *size = sizeof(mcontext.gp_regs);
 #else
   if (gp_regs)
     *gp_regs = &regs;
@@ -294,6 +334,11 @@
     *fp_regs = &mcontext.fpregs;
   if (size)
     *size = sizeof(mcontext.fpregs);
+#elif defined(__powerpc64__)
+  if (fp_regs)
+    *fp_regs = &mcontext.fp_regs;
+  if (size)
+    *size = sizeof(mcontext.fp_regs);
 #else
   if (fp_regs)
     *fp_regs = &fpregs;
@@ -302,4 +347,13 @@
 #endif
 }
 
+#if defined(__powerpc64__)
+void ThreadInfo::GetVectorRegisters(void** v_regs, size_t* size) {
+    if (v_regs)
+        *v_regs = &vregs;
+    if (size)
+        *size = sizeof(vregs);
+}
+#endif
+
 }  // namespace google_breakpad
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h	2020-04-08 22:26:44.244466132 +0000
@@ -68,6 +68,10 @@
   // Use the structures defined in <sys/user.h>
   struct user_regs_struct regs;
   struct user_fpsimd_struct fpregs;
+#elif defined(__powerpc64__)
+  // Use the structures defined in <sys/ucontext.h>.
+  mcontext_t mcontext;
+  struct _libc_vrstate vregs;
 #elif defined(__mips__)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
@@ -84,6 +88,11 @@
 
   // Returns the pointer and size of float point register area.
   void GetFloatingPointRegisters(void** fp_regs, size_t* size);
+
+#if defined(__powerpc64__)
+  // Returns the pointer and size of the vector register area. (PPC64 only)
+  void GetVectorRegisters(void** v_regs, size_t* size);
+#endif
 };
 
 }  // namespace google_breakpad
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc	2020-04-08 22:26:44.244466132 +0000
@@ -254,6 +254,48 @@
   out->float_save.fir = uc->uc_mcontext.fpc_eir;  // Unused.
 #endif
 }
+
+#elif defined(__powerpc64__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+    return uc->uc_mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+    return uc->uc_mcontext.gp_regs[PT_NIP];
+}
+
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                                    const struct _libc_vrstate* vregs) {
+    out->context_flags = MD_CONTEXT_PPC64_FULL;
+
+    for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+        out->gpr[i] = uc->uc_mcontext.gp_regs[i];
+
+    out->lr = uc->uc_mcontext.gp_regs[PT_LNK];    
+    out->srr0 = uc->uc_mcontext.gp_regs[PT_NIP];
+    out->srr1 = uc->uc_mcontext.gp_regs[PT_MSR];
+    out->cr = uc->uc_mcontext.gp_regs[PT_CCR];
+    out->xer = uc->uc_mcontext.gp_regs[PT_XER];
+    out->ctr = uc->uc_mcontext.gp_regs[PT_CTR];
+    
+    for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+        out->float_save.fpregs[i] = uc->uc_mcontext.fp_regs[i];
+
+    out->float_save.fpscr = uc->uc_mcontext.fp_regs[NFPREG-1];
+
+    for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++)
+        out->vector_save.save_vr[i] =
+            {(((uint64_t)vregs->vrregs[i][0]) << 32) 
+                         | vregs->vrregs[i][1], 
+             (((uint64_t)vregs->vrregs[i][2]) << 32)
+                         | vregs->vrregs[i][3]};
+
+    out->vrsave = vregs->vrsave;
+    out->vector_save.save_vscr = {0, vregs->vscr.vscr_word};
+    out->vector_save.save_vrvalid = 0xFFFFFFFF; 
+}
+
 #endif
 
 }  // namespace google_breakpad
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h	2020-04-08 22:26:44.244466132 +0000
@@ -54,6 +54,9 @@
 #elif defined(__aarch64__)
   static void FillCPUContext(RawContextCPU *out, const ucontext_t *uc,
                              const struct fpsimd_context* fpregs);
+#elif defined(__powerpc64__)
+  static void FillCPUContext(RawContextCPU *out, const ucontext_t *uc,
+                             const struct _libc_vrstate* vregs);
 #else
   static void FillCPUContext(RawContextCPU *out, const ucontext_t *uc);
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc	2020-04-08 22:26:44.244466132 +0000
@@ -461,9 +461,16 @@
     memcpy(&g_crash_context_.float_state, fp_ptr,
            sizeof(g_crash_context_.float_state));
   }
+#elif defined(__powerpc64__)
+  // On PPC64, we must copy VR state
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
+  if (uc_ptr->uc_mcontext.v_regs) {
+    memcpy(&g_crash_context_.vector_state, uc_ptr->uc_mcontext.v_regs,
+           sizeof(g_crash_context_.vector_state));
+  }
 #elif !defined(__ARM_EABI__) && !defined(__mips__)
   // FP state is not part of user ABI on ARM Linux.
-  // In case of MIPS Linux FP state is already part of ucontext_t
+  // In case of MIPS, Linux FP state is already part of ucontext_t
   // and 'float_state' is not a member of CrashContext.
   ucontext_t* uc_ptr = (ucontext_t*)uc;
   if (uc_ptr->uc_mcontext.fpregs) {
@@ -701,11 +708,19 @@
   }
 #endif
 
-#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__) \
+    && !defined(__powerpc64__)
   // FPU state is not part of ARM EABI ucontext_t.
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
 #endif
+
+#if defined(__powerpc64__)
+  // Vector registers must be copied on PPC64
+  memcpy(&context.vector_state, context.context.uc_mcontext.v_regs,
+         sizeof(context.vector_state));
+#endif
+
   context.tid = sys_gettid();
 
   // Add an exception stream to the minidump for better reporting.
@@ -726,6 +741,9 @@
 #elif defined(__mips__)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.pc);
+#elif defined(__powerpc64__)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.gp_regs[PT_NIP]);
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h	2020-04-08 22:26:44.244466132 +0000
@@ -192,7 +192,11 @@
     siginfo_t siginfo;
     pid_t tid;  // the crashing thread.
     ucontext_t context;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+    // PPC64's FP state is a part of ucontext_t like MIPS but the vector
+    // state is not, so a struct is needed.
+    vstate_t vector_state;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
     // #ifdef this out because FP state is not part of user ABI for Linux ARM.
     // In case of MIPS Linux FP state is already part of ucontext_t so
     // 'float_state' is not required.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -307,7 +307,7 @@
   }
 
   // Wait a while until the child should have crashed.
-  usleep(1000000);
+  usleep(2000000);
   // Kill the child if it is still running.
   kill(child, SIGKILL);
 
@@ -555,6 +555,8 @@
 #if defined(__mips__)
   // mfc2 zero,Impl - usually illegal in userspace.
   0x48, 0x00, 0x00, 0x48
+#elif defined(__powerpc64__)
+  0x01, 0x01, 0x01, 0x01 // Crashes on a tested POWER9 cpu
 #else
   // This crashes with SIGILL on x86/x86-64/arm.
   0xff, 0xff, 0xff, 0xff
@@ -750,10 +752,10 @@
 
   // These are defined here so the parent can use them to check the
   // data from the minidump afterwards.
-  // Use 4k here because the OS will hand out a single page even
+  // Use the page size here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const uint32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = getpagesize();  // bytes
   const int kOffset = kMemorySize - sizeof(kIllegalInstruction);
 
   const pid_t child = fork();
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc	2020-04-08 22:26:44.244466132 +0000
@@ -138,7 +138,9 @@
                   const MicrodumpExtraInfo& microdump_extra_info,
                   LinuxDumper* dumper)
       : ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+        vector_state_(context ? &context->vector_state : NULL),
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -337,6 +339,8 @@
 # else
 #  error "This mips ABI is currently not supported (n32)"
 #endif
+#elif defined(__powerpc64__)
+    const char kArch[] = "ppc64";
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -409,7 +413,9 @@
   void DumpCPUState() {
     RawContextCPU cpu;
     my_memset(&cpu, 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+    UContextReader::FillCPUContext(&cpu, ucontext_, vector_state_);
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
     UContextReader::FillCPUContext(&cpu, ucontext_, float_state_);
 #else
     UContextReader::FillCPUContext(&cpu, ucontext_);
@@ -605,7 +611,9 @@
   void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
 
   const ucontext_t* const ucontext_;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+  const google_breakpad::vstate_t* const vector_state_;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
   const google_breakpad::fpstate_t* const float_state_;
 #endif
   LinuxDumper* dumper_;
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -278,10 +278,19 @@
   CrashAndGetMicrodump(mappings, MicrodumpExtraInfo(), &buf);
   ASSERT_TRUE(ContainsMicrodump(buf));
 
+  int page_size = getpagesize();
 #ifdef __LP64__
-  ASSERT_NE(std::string::npos,
-            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
-                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  // This test is only available for the following page sizes
+  ASSERT_TRUE((page_size == 4096) || (page_size == 65536));
+  if (page_size == 4096) { 
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  } else {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000010000 000000000000002A 0000000000010000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  }
 #else
   ASSERT_NE(std::string::npos,
             buf.find("M 00001000 0000002A 00001000 "
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc	2020-04-08 22:26:44.244466132 +0000
@@ -111,6 +111,9 @@
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
+#elif defined(__powerpc64__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP]);
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
@@ -195,7 +198,10 @@
         memset(&info, 0, sizeof(ThreadInfo));
         info.tgid = status->pr_pgrp;
         info.ppid = status->pr_ppid;
-#if defined(__mips__)
+#if defined(__powerpc64__)
+        for (int i = 0; i < 31; i++)
+            info.mcontext.gp_regs[i] = status->pr_reg[i];
+#elif defined(__mips__)
 #if defined(__ANDROID__)
         for (int i = EF_R0; i <= EF_R31; i++)
           info.mcontext.gregs[i - EF_R0] = status->pr_reg[i];
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.cc	2020-04-08 22:26:44.244466132 +0000
@@ -798,7 +798,9 @@
       reinterpret_cast<uint8_t*>(int_stack_pointer & ~(page_size - 1));
 
   // The number of bytes of stack which we try to capture.
-  static const ptrdiff_t kStackToCapture = 32 * 1024;
+  // This now depends on page_size to avoid missing data
+  // on systems with larger page sizes.
+  static const ptrdiff_t kStackToCapture = 8 * page_size;
 
   const MappingInfo* mapping = FindMapping(stack_pointer);
   if (!mapping)
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h	2020-04-08 22:26:44.244466132 +0000
@@ -60,7 +60,8 @@
  (defined(__mips__) && _MIPS_SIM == _ABIO32)
 typedef Elf32_auxv_t elf_aux_entry;
 #elif defined(__x86_64) || defined(__aarch64__) || \
-     (defined(__mips__) && _MIPS_SIM != _ABIO32)
+     (defined(__mips__) && _MIPS_SIM != _ABIO32) || \
+     defined(__powerpc64__)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc	2020-04-08 22:26:44.244466132 +0000
@@ -51,6 +51,8 @@
 #define TID_PTR_REGISTER "rcx"
 #elif defined(__mips__)
 #define TID_PTR_REGISTER "$1"
+#elif defined(__powerpc64__)
+#define TID_PTR_REGISTER "r8"
 #else
 #error This test has not been ported to this platform.
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc	2020-04-08 22:26:44.244466132 +0000
@@ -149,19 +149,27 @@
   return true;
 }
 
-bool LinuxPtraceDumper::ReadRegisterSet(ThreadInfo* info, pid_t tid)
-{
+bool LinuxPtraceDumper::ReadRegisterSet(ThreadInfo* info, pid_t tid) {
 #ifdef PTRACE_GETREGSET
   struct iovec io;
   info->GetGeneralPurposeRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_PRSTATUS, (void*)&io) == -1) {
     return false;
   }
 
   info->GetFloatingPointRegisters(&io.iov_base, &io.iov_len);
-  if (sys_ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_FPREGSET, (void*)&io) == -1) {
     return false;
   }
+
+#if defined(__powerpc64__)
+  // Grab the vector registers on PPC64 too
+  info->GetVectorRegisters(&io.iov_base, &io.iov_len);
+  if (ptrace(PTRACE_GETREGSET, tid, (void*)NT_PPC_VMX, (void*)&io) == -1) {
+    return false;
+  }
+#endif // defined(__powerpc64__)
+
   return true;
 #else
   return false;
@@ -298,6 +306,9 @@
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
+#elif defined(__powerpc64__)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP]);
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -457,6 +457,9 @@
 #elif defined(__mips__)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.gregs[1]);
+#elif defined(__powerpc64__)
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.mcontext.gp_regs[8]);
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -553,6 +556,8 @@
   uintptr_t heap_addr = thread_info.regs.rcx;
 #elif defined(__mips__)
   uintptr_t heap_addr = thread_info.mcontext.gregs[1];
+#elif defined(__powerpc64__)
+  uintptr_t heap_addr = thread_info.mcontext.gp_regs[8];
 #else
 #error This test has not been ported to this platform.
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc	2020-04-08 22:26:44.244466132 +0000
@@ -136,7 +136,9 @@
       : fd_(minidump_fd),
         path_(minidump_path),
         ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+        vector_state_(context ? &context->vector_state : NULL),
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -468,7 +470,9 @@
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+        UContextReader::FillCPUContext(cpu.get(), ucontext_, vector_state_);
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
         UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
 #else
         UContextReader::FillCPUContext(cpu.get(), ucontext_);
@@ -891,7 +895,7 @@
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__powerpc64__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -911,7 +915,9 @@
 
     // processor_architecture should always be set, do this first
     sys_info->processor_architecture =
-#if defined(__mips__)
+#if defined(__powerpc64__)
+        MD_CPU_ARCHITECTURE_PPC64;
+#elif defined(__mips__)
 # if _MIPS_SIM == _ABIO32
         MD_CPU_ARCHITECTURE_MIPS;
 # elif _MIPS_SIM == _ABI64
@@ -1327,7 +1333,9 @@
   const char* path_;  // Path to the file where the minidum should be written.
 
   const ucontext_t* const ucontext_;  // also from the signal handler
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if defined(__powerpc64__)
+  const google_breakpad::vstate_t* const vector_state_;
+#elif !defined(__ARM_EABI__) && !defined(__mips__)
   const google_breakpad::fpstate_t* const float_state_;  // ditto
 #endif
   LinuxDumper* dumper_;
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h	2020-04-08 22:26:44.244466132 +0000
@@ -47,6 +47,8 @@
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
+#elif defined(__powerpc64__)
+typedef struct _libc_vrstate vstate_t;
 #elif !defined(__ARM_EABI__) && !defined(__mips__)
 typedef struct _libc_fpstate fpstate_t;
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -710,6 +710,9 @@
 #elif defined(__mips__)
   context.context.uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP] =
       invalid_stack_pointer;
+#elif defined(__powerpc64__)
+  context.context.uc_mcontext.gp_regs[MD_CONTEXT_PPC64_REG_SP] =
+      invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc	2020-04-08 22:26:44.244466132 +0000
@@ -65,8 +65,7 @@
   }
 
 #if defined(__x86_64__) || defined(__aarch64__) || \
-   (defined(__mips__) && _MIPS_SIM == _ABI64)
-
+   (defined(__mips__) && _MIPS_SIM == _ABI64) || defined(__powerpc64__)
   struct kernel_stat st;
   if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
 #else
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -176,9 +176,10 @@
 TEST_F(MemoryMappedFileTest, MapWithOffset) {
   // Put more data in the test file this time. Offsets can only be
   // done on page boundaries, so we need a two page file to test this.
-  const int page_size = 4096;
-  char data1[2 * page_size];
-  size_t data1_size = sizeof(data1);
+  const int page_size = getpagesize();
+  char *data1 = static_cast<char*>(malloc(2 * page_size));
+  EXPECT_TRUE(data1 != NULL);
+  size_t data1_size = (2 * page_size);
   for (size_t i = 0; i < data1_size; ++i) {
     data1[i] = i & 0x7f;
   }
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -57,8 +57,9 @@
 
   EXPECT_EQ(0U, allocator.pages_allocated());
   uint8_t *p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  uint64_t expected_pages = 1 + ((10000 - 1) / getpagesize());
   ASSERT_FALSE(p == NULL);
-  EXPECT_EQ(3U, allocator.pages_allocated());
+  EXPECT_EQ(expected_pages, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
     uint8_t *p = reinterpret_cast<uint8_t*>(allocator.Alloc(i));
     ASSERT_FALSE(p == NULL);
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_linux.cc	2020-04-08 22:26:44.244466132 +0000
@@ -202,12 +202,14 @@
   // Check architecture and set architecture variable to corresponding flag
   // in objdump.
   switch (context->GetContextCPU()) {
+#if defined(__i386) || defined(__x86_64)
     case MD_CONTEXT_X86:
       architecture = "i386";
       break;
     case MD_CONTEXT_AMD64:
       architecture = "i386:x86-64";
       break;
+#endif
     default:
       // Unsupported architecture. Note that ARM architectures are not
       // supported because objdump does not support ARM.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc	2020-04-08 22:26:44.244466132 +0000
@@ -104,6 +104,8 @@
 }
 
 TEST(ExploitabilityTest, TestWindowsEngine) {
+// The following tests are only executable on an x86-class linux machine.
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("ascii_read_av.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -136,9 +138,12 @@
             ExploitabilityFor("read_av_clobber_write.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_LOW,
             ExploitabilityFor("read_av_conditional.dmp"));
+#endif
 }
 
 TEST(ExploitabilityTest, TestLinuxEngine) {
+// The following tests are only executable on an x86-class linux machine.
+#if defined(__i386) || defined(__x86_64)
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_INTERESTING,
             ExploitabilityFor("linux_null_read_av.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -171,7 +176,8 @@
             ExploitabilityFor("linux_executable_heap.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("linux_jmp_to_module_not_exe_region.dmp"));
-#ifndef _WIN32
+#endif
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
             ExploitabilityFor("linux_write_to_nonwritable_module.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_HIGH,
@@ -182,10 +188,10 @@
             ExploitabilityFor("linux_write_to_outside_module_via_math.dmp"));
   ASSERT_EQ(google_breakpad::EXPLOITABILITY_INTERESTING,
             ExploitabilityFor("linux_write_to_under_4k.dmp"));
-#endif  // _WIN32
+#endif  // !defined(_WIN32) && (!defined(__i386) && !defined(__x86_64))
 }
 
-#ifndef _WIN32
+#if !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
 TEST(ExploitabilityLinuxUtilsTest, DisassembleBytesTest) {
   ASSERT_FALSE(ExploitabilityLinuxTest::DisassembleBytes("", NULL, 5, NULL));
   uint8_t bytes[6] = {0xc7, 0x0, 0x5, 0x0, 0x0, 0x0};
@@ -301,6 +307,7 @@
                                                          context,
                                                          &write_address));
 }
-#endif  // _WIN32
+#endif  // !defined(_WIN32) && (defined(__i386) || defined(__x86_64))
+
 
 }  // namespace
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc	2020-04-08 22:26:44.244466132 +0000
@@ -76,6 +76,8 @@
   #define ELF_ARCH  EM_MIPS
 #elif defined(__aarch64__)
   #define ELF_ARCH  EM_AARCH64
+#elif defined(__powerpc64__)
+  #define ELF_ARCH  EM_PPC64
 #endif
 
 #if defined(__arm__)
@@ -86,6 +88,8 @@
 #elif defined (__mips__)
 // This file-local typedef simplifies the source code.
 typedef gregset_t user_regs_struct;
+#elif defined(__powerpc64__)
+typedef struct pt_regs user_regs_struct;
 #endif
 
 using google_breakpad::MDTypeHelper;
@@ -321,6 +325,9 @@
 #if defined(__aarch64__)
     user_fpsimd_struct fpregs;
 #endif
+#if defined(__powerpc64__)
+    mcontext_t mcontext;
+#endif
     uintptr_t stack_addr;
     const uint8_t* stack;
     size_t stack_length;
@@ -523,6 +530,38 @@
   thread->mcontext.fpc_eir = rawregs->float_save.fir;
 #endif
 }
+#elif defined(__powerpc64__)
+static void
+ParseThreadRegisters(CrashedProcess::Thread* thread,
+                     const MinidumpMemoryRange& range) {
+  const MDRawContextPPC64* rawregs = range.GetData<MDRawContextPPC64>(0);
+
+  for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+    thread->mcontext.gp_regs[i] = rawregs->gpr[i];
+
+  thread->mcontext.gp_regs[PT_LNK] = rawregs->lr;
+  thread->mcontext.gp_regs[PT_NIP] = rawregs->srr0;
+  thread->mcontext.gp_regs[PT_MSR] = rawregs->srr1;
+  thread->mcontext.gp_regs[PT_CCR] = rawregs->cr;
+  thread->mcontext.gp_regs[PT_XER] = rawregs->xer;
+  thread->mcontext.gp_regs[PT_CTR] = rawregs->ctr;
+  thread->mcontext.v_regs->vrsave = rawregs->vrsave;
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; i++)
+      thread->mcontext.fp_regs[i] = rawregs->float_save.fpregs[i];
+
+  thread->mcontext.fp_regs[NFPREG-1] = rawregs->float_save.fpscr;
+
+  for (int i = 0; i < MD_VECTORSAVEAREA_PPC_VR_COUNT; i++) {
+      thread->mcontext.v_regs->vrregs[i][0] = rawregs->vector_save.save_vr[i].high >> 32;
+      thread->mcontext.v_regs->vrregs[i][1] = rawregs->vector_save.save_vr[i].high;
+      thread->mcontext.v_regs->vrregs[i][2] = rawregs->vector_save.save_vr[i].low >> 32;
+      thread->mcontext.v_regs->vrregs[i][3] = rawregs->vector_save.save_vr[i].low;
+  }
+
+  thread->mcontext.v_regs->vscr.vscr_word = rawregs->vector_save.save_vscr.low & 0xFFFFFFFF;
+}
+
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -611,6 +650,12 @@
 # else
 #  error "This mips ABI is currently not supported (n32)"
 # endif
+#elif defined(__powerpc64__)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_PPC64) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports PPC64.\n");
+    exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/compat/linux/sys/user.h	2020-04-08 22:28:20.703125376 +0000
@@ -15,6 +15,7 @@
 #ifndef CRASHPAD_COMPAT_LINUX_SYS_USER_H_
 #define CRASHPAD_COMPAT_LINUX_SYS_USER_H_
 
+#include <cstddef>
 #include_next <sys/user.h>
 
 #include <features.h>
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context.h	2020-04-08 22:27:07.951678928 +0000
@@ -564,6 +564,70 @@
   uint64_t fir;
 };
 
+//! \brief ppc64-specific flags for MinidumpPPC64::context_flags
+//! Based on minidump_cpu_ppc64.h from breakpad
+enum MinidumpContextPPC64Flags : uint32_t {
+  //! \brief Identifies the context as PPC64.
+  kMinidumpContextPPC64 = 0x01000000,
+
+  //! \brief Indicates the validity of general purpose registers.
+  //!
+  //! Registers `r0`-`r31`, `nip`, `msr`, `lr`, etc. are valid.
+  kMinidumpContextPPC64Base = kMinidumpContextPPC64 | 0x00000001,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Registers `fp0`-`fp31`, `fpscr` are valid.
+  kMinidumpContextPPC64Floating = kMinidumpContextPPC64 | 0x00000008,
+
+  //! \brief Indicates the validity of Altivec/VMX registers.
+  //!
+  //! Registers `v0`-`v31`, `vscr`, `vrsave`.
+  kMinidumpContextPPC64Vector = kMinidumpContextPPC64 | 0x00000020,
+
+  //! \brief Indicates the validity of all registers
+  kMinidumpContextPPC64All = kMinidumpContextPPC64Base     |
+                             kMinidumpContextPPC64Floating |
+                             kMinidumpContextPPC64Vector
+};
+
+//! \brief A PPC64 CPU context carried in a minidump file.
+//! Based on minidump_cpu_ppc64.h from breakpad.
+struct MinidumpContextPPC64 {
+  uint64_t context_flags;
+
+  //! \brief General purpose registers.
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t regs[32];
+  uint64_t ccr;
+  uint64_t xer;
+  uint64_t lnk;
+  uint64_t ctr;
+
+  //! \brief Floating point registers.
+  double fpregs[32];
+
+  //! \brief FPU status register.
+  double fpscr;
+
+  //! \brief Altivec/VMX vector registers.
+  struct {
+      //! \brief Vector registers are 128bits.
+      uint128_struct save_vr[32];
+      uint128_struct save_vscr;
+
+      //! \brief Padding included for breakpad compatibiltiy.
+      uint32_t save_pad5[4];
+
+      //! \brief VRSAVE register.
+      uint32_t save_vrsave;
+
+      //! \brief Padding included for breakpad compatibiltiy.
+      uint32_t save_pad6[7];
+  } vregs;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc	2020-04-08 22:27:07.951678928 +0000
@@ -101,6 +101,13 @@
       break;
     }
 
+    case kCPUArchitecturePPC64: {
+      context = std::make_unique<MinidumpContextPPC64Writer>();
+      reinterpret_cast<MinidumpContextPPC64Writer*>(context.get())
+          ->InitalizeFromSnapshot(context_snapshot->ppc64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -449,5 +456,48 @@
   DCHECK_GE(state(), kStateFrozen);
   return sizeof(context_);
 }
+
+MinidumpContextPPC64Writer::MinidumpContextPPC64Writer()
+  : MinidumpContextWriter(), context_() {
+    context_.context_flags = kMinidumpContextPPC64;
+}
+
+MinidumpContextPPC64Writer::~MinidumpContextPPC64Writer() = default;
+
+void MinidumpContextPPC64Writer::InitalizeFromSnapshot(
+    const CPUContextPPC64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextPPC64);
+
+  context_.context_flags = kMinidumpContextPPC64All;
+
+  memcpy(context_.regs, context_snapshot->regs, sizeof(context_.regs));
+  context_.nip = context_snapshot->nip;
+  context_.msr = context_snapshot->msr;
+  context_.ccr = context_snapshot->ccr;
+  context_.xer = context_snapshot->xer;
+  context_.lnk = context_snapshot->lnk;
+  context_.ctr = context_snapshot->ctr;
+
+  memcpy(context_.fpregs, context_snapshot->fpregs, sizeof(context_.fpregs));
+  context_.fpscr = context_snapshot->fpscr;
+
+  memcpy(context_.vregs.save_vr, context_snapshot->vregs.save_vr,
+         sizeof(context_.vregs.save_vr));
+  memcpy(&context_.vregs.save_vscr, &context_snapshot->vregs.save_vscr,
+         sizeof(context_.vregs.save_vscr));
+  context_.vregs.save_vrsave = context_snapshot->vregs.save_vrsave;
+}
+
+bool MinidumpContextPPC64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextPPC64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
 
 }  // namespace crashpad
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer.h	2020-04-08 22:27:07.951678928 +0000
@@ -315,6 +315,45 @@
   DISALLOW_COPY_AND_ASSIGN(MinidumpContextMIPS64Writer);
 };
 
+class MinidumpContextPPC64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextPPC64Writer();
+  ~MinidumpContextPPC64Writer() override;
+
+  //! \brief Initalizes the MinidumpContextPPC64 based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitalizeFromSnapshot(const CPUContextPPC64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this objects private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextPPC64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextPPC64 context_;
+
+  DISALLOW_COPY_AND_ASSIGN(MinidumpContextPPC64Writer);
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc	2020-04-08 22:27:07.951678928 +0000
@@ -213,6 +213,21 @@
       context, ExpectMinidumpContextMIPS64, kSeed);
 }
 
+TEST(MinidumpContextWriter, PPC64_Zeros) {
+  EmptyContextTest<MinidumpContextPPC64Writer, MinidumpContextPPC64>(
+    ExpectMinidumpContextPPC64);
+}
+
+TEST(MinidumpContextWriter, PPC64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextPPC64 context_ppc64;
+  CPUContext context;
+  context.ppc64 = &context_ppc64;
+  InitializeCPUContextPPC64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextPPC64Writer, MinidumpContextPPC64>(
+      context, ExpectMinidumpContextPPC64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc	2020-04-08 22:27:07.951678928 +0000
@@ -126,6 +126,8 @@
   static constexpr char kCPU[] = "mips";
 #elif defined(ARCH_CPU_MIPS64EL)
   static constexpr char kCPU[] = "mips64";
+#elif defined(ARCH_CPU_PPC64)
+  static constexpr char kCPU[] = "ppc64";
 #else
 #error define kCPU for this CPU
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/capture_memory.cc	2020-04-08 22:27:17.850515125 +0000
@@ -110,6 +110,11 @@
   for (size_t i = 0; i < arraysize(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  MaybeCaptureMemoryAround(delegate, context.ppc64->nip);
+  for (size_t i = 0; i < base::size(context.ppc64->regs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.ppc64->regs[i]);
+  }
 #else
 #error Port.
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_architecture.h	2020-04-08 22:27:17.850515125 +0000
@@ -43,7 +43,10 @@
   kCPUArchitectureMIPSEL,
 
   //! \brief 64-bit MIPSEL.
-  kCPUArchitectureMIPS64EL
+  kCPUArchitectureMIPS64EL,
+
+  //! \brief 64-bit PPC64.
+  kCPUArchitecturePPC64
 };
 
 }  // namespace crashpad
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.cc	2020-04-08 22:27:17.850515125 +0000
@@ -168,6 +168,8 @@
       return arm->pc;
     case kCPUArchitectureARM64:
       return arm64->pc;
+    case kCPUArchitecturePPC64:
+      return ppc64->nip;
     default:
       NOTREACHED();
       return ~0ull;
@@ -184,6 +186,8 @@
       return arm->sp;
     case kCPUArchitectureARM64:
       return arm64->sp;
+    case kCPUArchitecturePPC64:
+      return ppc64->regs[1];
     default:
       NOTREACHED();
       return ~0ull;
@@ -195,6 +199,7 @@
     case kCPUArchitectureX86_64:
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
+    case kCPUArchitecturePPC64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/cpu_context.h	2020-04-08 22:27:17.850515125 +0000
@@ -352,6 +352,24 @@
   uint64_t fir;
 };
 
+//! \brief A context structure carrying PPC64 CPU state.
+struct CPUContextPPC64 {
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t regs[32];
+  uint64_t ccr;
+  uint64_t xer;
+  uint64_t lnk;
+  uint64_t ctr;
+  double fpregs[32];
+  double fpscr;
+  struct {
+    uint128_struct save_vr[32];
+    uint128_struct save_vscr;
+    uint32_t save_vrsave;
+  } vregs;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -382,6 +400,7 @@
     CPUContextARM64* arm64;
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
+    CPUContextPPC64* ppc64;
   };
 };
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h	2020-04-08 22:27:17.850515125 +0000
@@ -15,6 +15,7 @@
 #ifndef CRASHPAD_SNAPSHOT_LINUX_CPU_CONTEXT_LINUX_H_
 #define CRASHPAD_SNAPSHOT_LINUX_CPU_CONTEXT_LINUX_H_
 
+#include <cstring>
 #include "build/build_config.h"
 #include "snapshot/cpu_context.h"
 #include "snapshot/linux/signal_context.h"
@@ -174,6 +175,78 @@
 
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
+#if defined(ARCH_CPU_PPC64_FAMILY) || DOXYGEN
+
+//! \brief Initalizes a CPUContextPPC64 structure from native context
+//!     structures on Linux.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[in] vector_context The native vector context.
+//! \param[out] context The CPUContextPPC64 structure to initalize.
+template <typename Traits>
+void InitializeCPUContextPPC64(
+    const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    const VectorContext::v64_t& vector_context,
+    typename Traits::CPUContext* context) {
+
+  memcpy(context->regs, thread_context.gpr, sizeof(context->regs));
+  context->nip = thread_context.nip;
+  context->msr = thread_context.msr;
+  context->ccr = thread_context.ccr;
+  context->xer = thread_context.xer;
+  context->lnk = thread_context.lnk;
+  context->ctr = thread_context.ctr;
+
+  memcpy(context->fpregs, float_context.fpregs, sizeof(context->fpregs));
+  context->fpscr = float_context.fpscr;
+
+  for (uint8_t i = 0; i < 32; i++) {
+    context->vregs.save_vr[i] = {
+      (((uint64_t)vector_context.vrregs[i][0]) << 32) |
+        vector_context.vrregs[i][1],
+      (((uint64_t)vector_context.vrregs[i][2]) << 32) |
+        vector_context.vrregs[i][3]
+    };
+  }
+  context->vregs.save_vrsave = vector_context.vrsave;
+  context->vregs.save_vscr = {0, (uint64_t)vector_context.vscr.vscr_word};
+}
+
+template <typename Traits>
+void InitializeCPUContextPPC64(
+    const SignalThreadContext64 &thread_context,
+    const SignalFloatContext64 &float_context,
+    const SignalVectorContext64 &vector_context,
+    typename Traits::CPUContext* context) {
+
+  memcpy(context->regs, thread_context.regs, sizeof(context->regs));
+  context->nip = thread_context.nip;
+  context->msr = thread_context.msr;
+  context->ccr = thread_context.ccr;
+  context->xer = thread_context.xer;
+  context->lnk = thread_context.lnk;
+  context->ctr = thread_context.ctr;
+
+  memcpy(context->fpregs, float_context.regs, sizeof(context->fpregs));
+  context->fpscr = float_context.fpscr;
+
+  for (uint8_t i = 0; i < 32; i++) {
+    context->vregs.save_vr[i] = {
+      (((uint64_t)vector_context.vrregs[i][0]) << 32) |
+        vector_context.vrregs[i][1],
+      (((uint64_t)vector_context.vrregs[i][2]) << 32) |
+        vector_context.vrregs[i][3]
+    };
+  }
+  context->vregs.save_vrsave = vector_context.vrsave;
+  context->vregs.save_vscr = {0, (uint64_t)vector_context.vscr.vscr_word};
+}
+
+
+#endif
+
 }  // namespace internal
 }  // namespace crashpad
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/debug_rendezvous_test.cc	2020-04-08 22:27:17.850515125 +0000
@@ -158,9 +158,11 @@
           const bool is_vdso_mapping =
               device == 0 && inode == 0 && mapping_name == "[vdso]";
           static constexpr char kPrefix[] = "linux-vdso.so.";
+          static constexpr char kPrefix64[] = "linux-vdso64.so.";
           return is_vdso_mapping ==
                  (module_name.empty() ||
-                  module_name.compare(0, strlen(kPrefix), kPrefix) == 0);
+                  module_name.compare(0, strlen(kPrefix), kPrefix) == 0 ||
+                  module_name.compare(0, strlen(kPrefix64), kPrefix64) == 0);
         },
         module_mapping->name,
         module_mapping->device,
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc	2020-04-08 22:27:17.850515125 +0000
@@ -323,6 +323,69 @@
       reader, context_address, context_.mips64);
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  LinuxVMAddress gp_regs_address = context_address +
+                                   offsetof(UContext, mcontext) +
+                                   offsetof(typename Traits::MContext, gp_regs);
+
+  typename Traits::SignalThreadContext thread_context;
+  if (!memory->Read(gp_regs_address, sizeof(thread_context), &thread_context)) {
+    LOG(ERROR) << "Couldn't read gp_regs!";
+    return false;
+  }
+
+  LinuxVMAddress fp_regs_address = context_address +
+                                   offsetof(UContext, mcontext) +
+                                   offsetof(typename Traits::MContext, fp_regs);
+
+  typename Traits::SignalFloatContext fp_context;
+  if (!memory->Read(fp_regs_address, sizeof(fp_context), &fp_context)) {
+    LOG(ERROR) << "Couldn't read fp_regs!";
+    return false;
+  }
+
+  LinuxVMAddress v_regs_ptr_address = context_address +
+                                  offsetof(UContext, mcontext) +
+                                  offsetof(typename Traits::MContext, vmx_reserve) + 8;
+
+  typename Traits::SignalVectorContext v_context;
+  if (!memory->Read(v_regs_ptr_address, sizeof(v_context), &v_context)) {
+    LOG(ERROR) << "Couldn't read v_regs!";
+    return false;
+  }
+
+  InitializeCPUContextPPC64<ContextTraits64>(thread_context, fp_context,
+                            v_context, dest_context);
+
+  return true;
+}
+
+template<>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitecturePPC64;
+  context_.ppc64 = &context_union_.ppc64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.ppc64);
+}
+
+template<>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits32>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  // PPC64 is 64-bit
+  return false;
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(ProcessReaderLinux* process_reader,
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h	2020-04-08 22:27:17.850515125 +0000
@@ -84,6 +84,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    CPUContextPPC64 ppc64;
 #endif
   } context_union_;
   CPUContext context_;
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc	2020-04-08 22:27:17.850515125 +0000
@@ -295,7 +295,28 @@
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+using NativeCPUContext = ucontext_t;
 
+void InitializeContext(NativeCPUContext* context) {
+  for (size_t reg = 0; reg < 32; ++reg) {
+    context->uc_mcontext.gp_regs[reg] = reg;
+  }
+
+  memset(&context->uc_mcontext.fp_regs, 44,
+      sizeof(context->uc_mcontext.fp_regs));
+}
+
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitecturePPC64);
+
+  for (size_t reg = 0; reg < 32; ++reg) {
+    EXPECT_EQ(actual.ppc64->regs[reg], expected.uc_mcontext.gp_regs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(actual.ppc64->fpregs, expected.uc_mcontext.fp_regs,
+            sizeof(actual.ppc64->fpregs)), 0);
+}
 #else
 #error Port.
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc	2020-04-08 22:27:17.850515125 +0000
@@ -103,6 +103,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
                                     : thread_info.thread_context.t32.regs[29];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  stack_pointer = thread_info.thread_context.t64.gpr[1];
 #else
 #error Port.
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/signal_context.h	2020-04-08 22:27:17.850515125 +0000
@@ -422,6 +422,89 @@
               "context offset mismatch");
 #endif
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+
+struct SignalThreadContext64 {
+  uint64_t regs[32];
+  uint64_t nip;
+  uint64_t msr;
+  uint64_t orig_r3;
+  uint64_t ctr;
+  uint64_t lnk;
+  uint64_t xer;
+  uint64_t ccr;
+  uint64_t softe;
+  uint64_t trap;
+  uint64_t dar;
+  uint64_t dsisr;
+  uint64_t result;
+  uint64_t dscr;
+  uint64_t fpr0[3];
+};
+
+struct SignalFloatContext64 {
+  double regs[32];
+  double fpscr;
+};
+
+struct SignalVectorContext64 {
+  int32_t vrregs[32][4];
+  struct {
+    int32_t __pad[3];
+    int32_t vscr_word;
+  } vscr;
+  int32_t vrsave;
+  int32_t __pad[3];
+} __attribute__((__aligned__(16)));
+
+
+#pragma pack(pop)
+struct MContext64 {
+  uint64_t reserved[4];
+  int32_t signal;
+  int32_t __pad0;
+  uint64_t handler;
+  uint64_t oldmask;
+  uint64_t pt_regs_ptr;
+  SignalThreadContext64 gp_regs;
+  SignalFloatContext64  fp_regs;
+  SignalVectorContext64 *v_regs;
+  int64_t vmx_reserve[69];
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = SignalThreadContext64;
+  using SignalFloatContext = SignalFloatContext64;
+  using SignalVectorContext = SignalVectorContext64;
+  using CPUContext = CPUContextPPC64;
+};
+
+struct ContextTraits32 : public Traits32 {};
+
+struct UContext {
+  uint64_t flags;
+  uint64_t link;
+  SignalStack<ContextTraits64> stack;
+  Sigset<ContextTraits64> sigmask;
+  MContext64 mcontext;
+};
+#pragma pack(push, 1)
+
+static_assert(sizeof(UContext) == sizeof(ucontext_t),
+              "ucontext_t size mismatch");
+static_assert(sizeof(MContext64) == sizeof(mcontext_t),
+              "mcontext_t size mismatch");
+static_assert(sizeof(SignalThreadContext64) == sizeof(gregset_t),
+              "gregset_t size mismatch");
+static_assert(sizeof(SignalFloatContext64) == sizeof(fpregset_t),
+              "fpregset_t size mismatch");
+static_assert(sizeof(SignalVectorContext64) == sizeof(_libc_vrstate),
+              "vrstate size mismatch");
+static_assert(offsetof(UContext, mcontext) ==
+              offsetof(ucontext_t, uc_mcontext), "mcontext offset mismatch");
+static_assert(offsetof(MContext64, gp_regs) ==
+              offsetof(mcontext_t, gp_regs), "gp_regs offset mismatch");
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc	2020-04-08 22:27:17.850515125 +0000
@@ -203,6 +203,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureMIPS64EL
                                     : kCPUArchitectureMIPSEL;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return kCPUArchitecturePPC64;
 #else
 #error port to your architecture
 #endif
@@ -218,6 +220,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return 0;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -238,6 +243,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return std::string();
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -371,6 +379,9 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return false;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  // Not yet implemented on PPC64
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc	2020-04-08 22:27:17.850515125 +0000
@@ -85,6 +85,14 @@
         thread.thread_info.float_context.f32,
         context_.mipsel);
   }
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  context_.architecture = kCPUArchitecturePPC64;
+  context_.ppc64 = &context_union_.ppc64;
+  InitializeCPUContextPPC64<ContextTraits64>(
+      thread.thread_info.thread_context.t64,
+      thread.thread_info.float_context.f64,
+      thread.thread_info.vector_context.v64,
+      context_.ppc64);
 #else
 #error Port.
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h	2020-04-08 22:27:17.850515125 +0000
@@ -68,6 +68,8 @@
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    CPUContextPPC64 ppc64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/auxiliary_vector.cc	2020-04-08 22:27:27.519378356 +0000
@@ -56,6 +56,11 @@
     if (type == AT_IGNORE) {
       continue;
     }
+#if defined(ARCH_CPU_PPC64_FAMILY)
+    if (type == AT_IGNOREPPC) {
+      continue;
+    }
+#endif
     if (!MapInsertOrReplace(&values_, type, value, nullptr)) {
       LOG(ERROR) << "duplicate auxv entry";
       return false;
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptrace_broker.cc	2020-04-08 22:27:27.519378356 +0000
@@ -92,8 +92,8 @@
 }
 
 bool PtraceBroker::AllocateAttachments() {
-  constexpr size_t page_size = 4096;
-  constexpr size_t alloc_size =
+  static size_t page_size = getpagesize();
+  size_t alloc_size =
       (sizeof(ScopedPtraceAttach) + page_size - 1) & ~(page_size - 1);
   void* alloc = sbrk(alloc_size);
   if (reinterpret_cast<intptr_t>(alloc) == -1) {
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/ptracer.cc	2020-04-08 22:27:27.529377181 +0000
@@ -394,6 +394,64 @@
   return true;
 }
 
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+// PPC64 has had HAVE_ARCH_TRACEHOOK set since 2.6.27 (even before x86 had it).
+// That means we can simply use PTRACE_GETREGESET.
+
+template <typename Destination>
+bool GetRegisterSet(pid_t tid, int set, Destination* dest, bool can_log) {
+  iovec iov;
+  iov.iov_base = reinterpret_cast<void*>(dest);
+  iov.iov_len = sizeof(*dest);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(set), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(*dest)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size";
+    return false;
+  }
+  return true;
+}
+
+bool GetVectorRegisters64(pid_t tid,
+                          VectorContext* context,
+                          bool can_log) {
+  return GetRegisterSet(tid, NT_PPC_VMX, &context->v64, can_log);
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return GetRegisterSet(tid, NT_PRFPREG, &context->f64, can_log);
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  // PPC64 doesn't have PTRACE_GET_THREAD_AREA since the thread pointer
+  // is stored in GPR 13.
+  ThreadContext::t64_t tc;
+  if (!GetRegisterSet(tid, NT_PRSTATUS, &tc, can_log)) {
+    LOG_IF(ERROR, can_log) << "Unable to get thread pointer!";
+    return false;
+  }
+
+  *address = tc.gpr[13];
+
+  return true;
+}
+
+// Stubs for 32-bit functions not applicable on PPC64
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) { return false; }
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext &context,
+                     LinuxVMAddress *address,
+                     bool can_log) { return false; }
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -486,6 +544,9 @@
   if (is_64_bit_) {
     return GetGeneralPurposeRegisters64(tid, &info->thread_context, can_log_) &&
            GetFloatingPointRegisters64(tid, &info->float_context, can_log_) &&
+#if defined(ARCH_CPU_PPC64_FAMILY)
+           GetVectorRegisters64(tid, &info->vector_context, can_log_) &&
+#endif
            GetThreadArea64(tid,
                            info->thread_context,
                            &info->thread_specific_data_address,
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/linux/thread_info.h	2020-04-08 22:27:27.529377181 +0000
@@ -28,6 +28,10 @@
 #include <android/api-level.h>
 #endif
 
+#if defined(ARCH_CPU_PPC64_FAMILY)
+#include <sys/ucontext.h>
+#endif
+
 namespace crashpad {
 
 //! \brief The set of general purpose registers for an architecture family.
@@ -79,6 +83,8 @@
     uint32_t cp0_status;
     uint32_t cp0_cause;
     uint32_t padding1_;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // PPC64 is 64-bit
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -132,6 +138,21 @@
     uint64_t cp0_badvaddr;
     uint64_t cp0_status;
     uint64_t cp0_cause;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects struct pt_regs in asm/ptrace.h.
+    uint64_t gpr[32];
+    uint64_t nip;
+    uint64_t msr;
+    uint64_t orig_gpr3;
+    uint64_t ctr;
+    uint64_t lnk;
+    uint64_t xer;
+    uint64_t ccr;
+    uint64_t softe;
+    uint64_t trap;
+    uint64_t dar;
+    uint64_t dsisr;
+    uint64_t result;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -143,6 +164,8 @@
   using NativeThreadContext = user_regs;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
 // No appropriate NativeThreadsContext type available for MIPS
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  using NativeThreadContext = struct pt_regs;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64
@@ -218,6 +241,9 @@
     } fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Crashpad's PPC support is 64-bit only, so this
+    // 32bit-only struct is declared as empty.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -252,6 +278,10 @@
     double fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects fpregset_t in sys/ucontext.h
+    double fpregs[32];
+    double fpscr;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -280,6 +310,8 @@
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
 #elif defined(ARCH_CPU_MIPS_FAMILY)
 // No appropriate floating point context native type for available MIPS.
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  static_assert(sizeof(f64) == sizeof(fpregset_t), "Size mismatch");
 #else
 #error Port.
 #endif  // ARCH_CPU_X86
@@ -287,6 +319,26 @@
 static_assert(std::is_standard_layout<FloatContext>::value,
               "Not standard layout");
 
+//! \brief The vector registers used for an architecture family
+union VectorContext {
+  struct v32_t {} v32;
+#if defined(ARCH_CPU_PPC64_FAMILY)
+  __attribute__((__aligned__(16))) // Vector context must be doubleword aligned.
+#endif
+  struct v64_t {
+#if defined(ARCH_CPU_PPC64_FAMILY)
+    // Reflects vrregset_t in sys/ucontext.h
+    uint32_t vrregs[32][4];
+    struct {
+      uint32_t __pad[3];
+      uint32_t vscr_word;
+    } vscr;
+    uint32_t vrsave;
+    uint32_t __pad[3];
+#endif
+  } v64;
+};
+
 //! \brief A collection of `ptrace`-able information about a thread.
 struct ThreadInfo {
   ThreadInfo();
@@ -298,6 +350,9 @@
   //! \brief The floating point registers for the thread.
   FloatContext float_context;
 
+  //! \brief (Optional) The vector registers used for the thread.
+  VectorContext vector_context;
+
   //! \brief The thread-local storage address for the thread.
   LinuxVMAddress thread_specific_data_address;
 };
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context.h	2020-04-08 22:27:27.529377181 +0000
@@ -66,6 +66,7 @@
 //!     macOS/Linux/Fuchsia | x86_64       | `%%rdi`
 //!     Linux               | ARM/ARM64    | `r0`/`x0`
 //!     Linux               | MIPS/MIPS64  | `$a0`
+//!     Linux               | PPC64        | `r3`
 //!
 //!     Additionally, the value `LR` on ARM/ARM64 will be the return address of
 //!     this function.
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_linux.S	2020-04-08 22:27:27.529377181 +0000
@@ -28,7 +28,7 @@
   .globl CAPTURECONTEXT_SYMBOL2
 #if defined(__i386__) || defined(__x86_64__)
   .balign 16, 0x90
-#elif defined(__arm__) || defined(__aarch64__) || defined(__mips__)
+#elif defined(__arm__) || defined(__aarch64__) || defined(__mips__) || defined(__powerpc64__)
   .balign 4, 0x0
 #endif
 
@@ -421,4 +421,214 @@
   jr $ra
 
   .set at
+#elif defined(__powerpc64__)
+  // Store r0-r31
+  std 0, 0xe8(3)   // context->uc_mcontext.gp_regs[0]
+  std 1, 0xf0(3)   // context->uc_mcontext.gp_regs[1]
+  std 2, 0xf8(3)   // context->uc_mcontext.gp_regs[2]
+  // note that r3's original value was lost
+  std 3, 0x100(3)  // context->uc_mcontext.gp_regs[3]
+  std 4, 0x108(3)  // context->uc_mcontext.gp_regs[4]
+  std 5, 0x110(3)  // context->uc_mcontext.gp_regs[5]
+  std 6, 0x118(3)  // context->uc_mcontext.gp_regs[6]
+  std 7, 0x120(3)  // context->uc_mcontext.gp_regs[7]
+  std 8, 0x128(3)  // context->uc_mcontext.gp_regs[8]
+  std 9, 0x130(3)  // context->uc_mcontext.gp_regs[9]
+  std 10, 0x138(3) // context->uc_mcontext.gp_regs[10]
+  std 11, 0x140(3) // context->uc_mcontext.gp_regs[11]
+  std 12, 0x148(3) // context->uc_mcontext.gp_regs[12]
+  std 13, 0x150(3) // context->uc_mcontext.gp_regs[13]
+  std 14, 0x158(3) // context->uc_mcontext.gp_regs[14]
+  std 15, 0x160(3) // context->uc_mcontext.gp_regs[15]
+  std 16, 0x168(3) // context->uc_mcontext.gp_regs[16]
+  std 17, 0x170(3) // context->uc_mcontext.gp_regs[17]
+  std 18, 0x178(3) // context->uc_mcontext.gp_regs[18]
+  std 19, 0x180(3) // context->uc_mcontext.gp_regs[19]
+  std 20, 0x188(3) // context->uc_mcontext.gp_regs[20]
+  std 21, 0x190(3) // context->uc_mcontext.gp_regs[21]
+  std 22, 0x198(3) // context->uc_mcontext.gp_regs[22]
+  std 23, 0x1a0(3) // context->uc_mcontext.gp_regs[23]
+  std 24, 0x1a8(3) // context->uc_mcontext.gp_regs[24]
+  std 25, 0x1b0(3) // context->uc_mcontext.gp_regs[25]
+  std 26, 0x1b8(3) // context->uc_mcontext.gp_regs[26]
+  std 27, 0x1c0(3) // context->uc_mcontext.gp_regs[27]
+  std 28, 0x1c8(3) // context->uc_mcontext.gp_regs[28]
+  std 29, 0x1d0(3) // context->uc_mcontext.gp_regs[29]
+  std 30, 0x1d8(3) // context->uc_mcontext.gp_regs[30]
+  std 31, 0x1e0(3) // context->uc_mcontext.gp_regs[31]
+
+  // For NIP, we can use the value in the link register
+  mflr 0
+  std 0, 0x1e8(3) // context->uc_mcontext.gp_regs[PT_NIP]
+
+  // CTR
+  mfctr 0
+  std 0, 0x200(3) // context->uc_mcontext.gp_regs[PT_CTR]
+
+  // For LNK, we'll use the caller's LR save area (2 stack frames up).
+  // r4 can be used as a scratch register since it has already been saved.
+  ld 4, 0(1)
+  ld 4, 16(4)
+  std 4, 0x208(3) // context->uc_mcontext.gp_regs[PT_LNK]
+
+  // XER
+  mfxer 0
+  std 0, 0x210(3) // context->uc_mcontext.gp_regs[PT_XER]
+
+  // CCR
+  mfcr 0
+  std 0, 0x218(3) // context->uc_mcontext.gp_regs[PT_CCR]
+
+  // MSR, orig_r3, MQ, TRAP, DAR, DSISR, RESULT, DSCR,
+  // not used or not relevant,  zero them out.
+  li 4, 0
+  std 4, 0x1f0(3) // context->uc_mcontext.gp_regs[PT_MSR]
+  std 4, 0x1f8(3) // context->uc_mcontext.gp_regs[PT_ORIG_R3]
+  std 4, 0x220(3) // context->uc_mcontext.gp_regs[PT_MQ]
+  std 4, 0x228(3) // context->uc_mcontext.gp_regs[PT_TRAP]
+  std 4, 0x230(3) // context->uc_mcontext.gp_regs[PT_DAR]
+  std 4, 0x238(3) // context->uc_mcontext.gp_regs[PT_DSISR]
+  std 4, 0x240(3) // context->uc_mcontext.gp_regs[PT_RESULT]
+  std 4, 0x248(3) // context->uc_mcontext.gp_regs[PT_DSCR]
+
+  // Update context->uc_mcontext.regs to point to gp_regs
+  addi 0, 3, 0xe8
+  std 0, 0xe0(3)
+
+  // Save floating point registers 0-31
+  stfd 0, 0x268(3)  // context->uc_mcontext.fp_regs[0]
+  stfd 1, 0x270(3)  // context->uc_mcontext.fp_regs[1]
+  stfd 2, 0x278(3)  // context->uc_mcontext.fp_regs[2]
+  stfd 3, 0x280(3)  // context->uc_mcontext.fp_regs[3]
+  stfd 4, 0x288(3)  // context->uc_mcontext.fp_regs[4]
+  stfd 5, 0x290(3)  // context->uc_mcontext.fp_regs[5]
+  stfd 6, 0x298(3)  // context->uc_mcontext.fp_regs[6]
+  stfd 7, 0x2a0(3)  // context->uc_mcontext.fp_regs[7]
+  stfd 8, 0x2a8(3)  // context->uc_mcontext.fp_regs[8]
+  stfd 9, 0x2b0(3)  // context->uc_mcontext.fp_regs[9]
+  stfd 10, 0x2b8(3) // context->uc_mcontext.fp_regs[10]
+  stfd 11, 0x2c0(3) // context->uc_mcontext.fp_regs[11]
+  stfd 12, 0x2c8(3) // context->uc_mcontext.fp_regs[12]
+  stfd 13, 0x2d0(3) // context->uc_mcontext.fp_regs[13]
+  stfd 14, 0x2d8(3) // context->uc_mcontext.fp_regs[14]
+  stfd 15, 0x2e0(3) // context->uc_mcontext.fp_regs[15]
+  stfd 16, 0x2e8(3) // context->uc_mcontext.fp_regs[16]
+  stfd 17, 0x2f0(3) // context->uc_mcontext.fp_regs[17]
+  stfd 18, 0x2f8(3) // context->uc_mcontext.fp_regs[18]
+  stfd 19, 0x300(3) // context->uc_mcontext.fp_regs[19]
+  stfd 20, 0x308(3) // context->uc_mcontext.fp_regs[20]
+  stfd 21, 0x310(3) // context->uc_mcontext.fp_regs[21]
+  stfd 22, 0x318(3) // context->uc_mcontext.fp_regs[22]
+  stfd 23, 0x320(3) // context->uc_mcontext.fp_regs[23]
+  stfd 24, 0x328(3) // context->uc_mcontext.fp_regs[24]
+  stfd 25, 0x330(3) // context->uc_mcontext.fp_regs[25]
+  stfd 26, 0x338(3) // context->uc_mcontext.fp_regs[26]
+  stfd 27, 0x340(3) // context->uc_mcontext.fp_regs[27]
+  stfd 28, 0x348(3) // context->uc_mcontext.fp_regs[28]
+  stfd 29, 0x350(3) // context->uc_mcontext.fp_regs[29]
+  stfd 30, 0x358(3) // context->uc_mcontext.fp_regs[30]
+  stfd 31, 0x360(3) // context->uc_mcontext.fp_regs[31]
+
+  // FPSCR
+  mffs 0
+  stfd 0, 0x368(3) // context->uc_mcontext.fp_regs[32]
+
+  // Save VMX Vector registers
+  // Update r4 to contain the base address of vmx_reserve
+  addi 4, 3, 0x378
+  // Ensure that it is quadword aligned
+  andi. 5, 4, 0xF
+  beq 1f // No alignment is necessary
+  // Address is doubleword aligned and not quadword aligned, add 8
+  addi 4, 4, 8
+
+1:
+  // Store VMX registers 0-31
+  // r4 will contain the base address
+  // r5 will contain the index
+  li 5, 0
+  stvx 0, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 0]
+  addi 5, 5, 16
+  stvx 1, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 1]
+  addi 5, 5, 16
+  stvx 2, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 2]
+  addi 5, 5, 16
+  stvx 3, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 3]
+  addi 5, 5, 16
+  stvx 4, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 4]
+  addi 5, 5, 16
+  stvx 5, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 5]
+  addi 5, 5, 16
+  stvx 6, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 6]
+  addi 5, 5, 16
+  stvx 7, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 7]
+  addi 5, 5, 16
+  stvx 8, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 8]
+  addi 5, 5, 16
+  stvx 9, 4, 5   // context->uc_mcontext.vmx_reserve[(align) + 9]
+  addi 5, 5, 16
+  stvx 10, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 10]
+  addi 5, 5, 16
+  stvx 11, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 11]
+  addi 5, 5, 16
+  stvx 12, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 12]
+  addi 5, 5, 16
+  stvx 13, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 13]
+  addi 5, 5, 16
+  stvx 14, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 14]
+  addi 5, 5, 16
+  stvx 15, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 15]
+  addi 5, 5, 16
+  stvx 16, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 16]
+  addi 5, 5, 16
+  stvx 17, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 17]
+  addi 5, 5, 16
+  stvx 18, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 18]
+  addi 5, 5, 16
+  stvx 19, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 19]
+  addi 5, 5, 16
+  stvx 20, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 20]
+  addi 5, 5, 16
+  stvx 21, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 21]
+  addi 5, 5, 16
+  stvx 22, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 22]
+  addi 5, 5, 16
+  stvx 23, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 23]
+  addi 5, 5, 16
+  stvx 24, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 24]
+  addi 5, 5, 16
+  stvx 25, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 25]
+  addi 5, 5, 16
+  stvx 26, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 26]
+  addi 5, 5, 16
+  stvx 27, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 27]
+  addi 5, 5, 16
+  stvx 28, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 28]
+  addi 5, 5, 16
+  stvx 29, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 29]
+  addi 5, 5, 16
+  stvx 30, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 30]
+  addi 5, 5, 16
+  stvx 31, 4, 5  // context->uc_mcontext.vmx_reserve[(align) + 31]
+  addi 5, 5, 16
+
+  // VSCR
+  mfvscr 0
+  stvx 0, 4, 5
+  addi 5, 5, 16
+
+  // VRSAVE
+  mfvrsave 0
+  stwx 0, 4, 5
+
+  // Update context->uc_mcontext.v_regs to point to vmx_reserve + alignment.
+  std 4, 0x370(3)
+
+  // Zero out all unused fields
+  li 4, 0
+  std 4, 0xc8(3) // context->uc_mcontext.signal
+  std 4, 0xd0(3) // context->uc_mcontext.handler
+  std 4, 0xd8(3) // context->uc_mcontext.oldmask
+
+  blr
 #endif  // __i386__
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test.cc	2020-04-08 22:27:27.529377181 +0000
@@ -49,7 +49,8 @@
   // reference program counter.
   uintptr_t pc = ProgramCounterFromContext(context_1);
 
-#if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY)
+#if !defined(ADDRESS_SANITIZER) && !defined(ARCH_CPU_MIPS_FAMILY) && \
+    !defined(ARCH_CPU_PPC64_FAMILY)
   // AddressSanitizer can cause enough code bloat that the nearby check would
   // likely fail.
   const uintptr_t kReferencePC =
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc	2020-04-08 22:27:27.529377181 +0000
@@ -36,6 +36,8 @@
   EXPECT_EQ(context.uc_mcontext.regs[0], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   EXPECT_EQ(context.uc_mcontext.gregs[4], FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  EXPECT_EQ(context.uc_mcontext.gp_regs[3], FromPointerCast<uintptr_t>(&context));
 #endif
 }
 
@@ -50,6 +52,8 @@
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.pc;
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return context.uc_mcontext.gp_regs[PT_NIP];
 #endif
 }
 
@@ -64,6 +68,8 @@
   return context.uc_mcontext.sp;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.gregs[29];
+#elif defined(ARCH_CPU_PPC64_FAMILY)
+  return context.uc_mcontext.gp_regs[1];
 #endif
 }
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/crashpad/crashpad/util/posix/signals_test.cc	2020-04-08 22:27:27.529377181 +0000
@@ -45,12 +45,12 @@
   return sig == SIGABRT ||
          sig == SIGALRM ||
          sig == SIGBUS ||
-#if !defined(ARCH_CPU_ARM64)
+#if !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
          sig == SIGFPE ||
-#endif  // !defined(ARCH_CPU_ARM64)
+#endif  // !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL)
          sig == SIGILL ||
-#endif  // defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL
+#endif  // defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL)
          sig == SIGPIPE ||
          sig == SIGSEGV ||
 #if defined(OS_MACOSX)
@@ -116,9 +116,11 @@
       break;
     }
 
-#if !defined(ARCH_CPU_ARM64)
+#if !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
     // ARM64 has hardware integer division instructions that dont generate a
     // trap for divide-by-zero, so this doesnt produce SIGFPE.
+    //
+    // PPC64 fixed-point division by zero also doesn't produce a SIGFPE.
     case SIGFPE: {
       // Optimization makes this tricky, so get zero from a system call likely
       // to succeed, and try to do something with the result.
@@ -136,7 +138,7 @@
       fstat(quotient, &stat_buf);
       break;
     }
-#endif  // ARCH_CPU_ARM64
+#endif  // !defined(ARCH_CPU_ARM64) && !defined(ARCH_CPU_PPC64)
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARMEL)
     case SIGILL: {
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libpng/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libpng/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libpng/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libpng/BUILD.gn	2020-04-08 22:46:36.164199240 +0000
@@ -92,6 +92,11 @@
       "mips/filter_msa_intrinsics.c",
       "mips/mips_init.c",
     ]
+  } else if (current_cpu == "ppc64") {
+    sources += [
+      "powerpc/filter_vsx_intrinsics.c",
+      "powerpc/powerpc_init.c",
+    ]
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libpng/powerpc/filter_vsx_intrinsics.c	2020-04-08 22:46:36.164199240 +0000
@@ -0,0 +1,767 @@
+/* filter_vsx_intrinsics.c - PowerPC optimised filter functions
+ *
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ * Last changed in libpng 1.6.29 [March 16, 2017]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+/* This code requires -maltivec and -mvsx on the command line: */
+#if PNG_POWERPC_VSX_IMPLEMENTATION == 1 /* intrinsics code from pngpriv.h */
+
+#include <altivec.h>
+
+#if PNG_POWERPC_VSX_OPT > 0
+
+#ifndef __VSX__
+#  error "This code requires VSX support (POWER7 and later). Please provide -mvsx compiler flag."
+#endif
+
+#define vec_ld_unaligned(vec,data) vec = vec_vsx_ld(0,data)
+#define vec_st_unaligned(vec,data) vec_vsx_st(vec,0,data)
+
+
+/* Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
+ * They're positioned like this:
+ *    prev:  c b
+ *    row:   a d
+ * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
+ * whichever of a, b, or c is closest to p=a+b-c.
+ * ( this is taken from ../intel/filter_sse2_intrinsics.c )
+ */
+
+#define vsx_declare_common_vars(row_info,row,prev_row,offset) \
+   png_byte i;\
+   png_bytep rp = row + offset;\
+   png_const_bytep pp = prev_row;\
+   png_size_t unaligned_top = 16 - (((png_size_t)rp % 16));\
+   png_size_t istop;\
+   if(unaligned_top == 16)\
+      unaligned_top = 0;\
+   istop = row_info->rowbytes;\
+   if((unaligned_top < istop))\
+      istop -= unaligned_top;\
+   else{\
+      unaligned_top = istop;\
+      istop = 0;\
+   }
+
+void png_read_filter_row_up_vsx(png_row_infop row_info, png_bytep row,
+                                png_const_bytep prev_row)
+{
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vsx_declare_common_vars(row_info,row,prev_row,0)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      rp_vec = vec_add(rp_vec,pp_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      pp += 16;
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+   {
+      /* If byte count of row is not divisible by 16
+       * we will process remaining part as usual
+       */
+      for (i = 0; i < istop; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+         rp++;
+      }
+}
+
+}
+
+static const vector unsigned char VSX_LEFTSHIFTED1_4 = {16,16,16,16, 0, 1, 2, 3,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_4 = {16,16,16,16,16,16,16,16, 4, 5, 6, 7,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 8, 9,10,11};
+
+static const vector unsigned char VSX_LEFTSHIFTED1_3 = {16,16,16, 0, 1, 2,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_3 = {16,16,16,16,16,16, 3, 4, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 6, 7, 8,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 9,10,11,16};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_4 = {16,16,16,16, 4, 5, 6, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_4 = {16,16,16,16,16,16,16,16, 8, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,15};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_3 = {16,16,16, 3, 4, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_3 = {16,16,16,16,16,16, 6, 7, 8,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,16};
+
+static const vector unsigned char VSX_CHAR_ZERO = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+#ifdef __LITTLE_ENDIAN__
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = { 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = { 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {12,16,13,16,14,16,15,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 0, 2, 4, 6,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 0, 2, 4, 6,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4, 6};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = { 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = { 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = { 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {12,16,13,16,14,16,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 0, 2, 4,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 0, 2, 4,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 0, 2, 4,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4,16};
+
+#elif defined(__BIG_ENDIAN__)
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = {16, 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = {16, 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {16,12,16,13,16,14,16,15,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 1, 3, 5, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 1, 3, 5, 7,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5, 7};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = {16, 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = {16, 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = {16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {16,12,16,13,16,14,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 1, 3, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 1, 3, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 1, 3, 5,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5,16};
+
+#endif
+
+#define vsx_char_to_short(vec,offset,bpp) (vector unsigned short)vec_perm((vec),VSX_CHAR_ZERO,VSX_CHAR_TO_SHORT##offset##_##bpp)
+#define vsx_short_to_char(vec,offset,bpp) vec_perm(((vector unsigned char)(vec)),VSX_CHAR_ZERO,VSX_SHORT_TO_CHAR##offset##_##bpp)
+
+#ifdef PNG_USE_ABS
+#  define vsx_abs(number) abs(number)
+#else
+#  define vsx_abs(number) (number > 0) ? (number) : -(number)
+#endif
+
+void png_read_filter_row_sub4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp - bpp))) & 0xff);
+         rp++;
+      }
+
+}
+
+void png_read_filter_row_sub3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 3;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+      rp += 15;
+      istop -= 16;
+
+      /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+       * be proceeded manually
+       */
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned char pp_part_vec;
+   vector unsigned char rp_part_vec;
+   vector unsigned char avg_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         ((int)(*pp++) / 2 )) & 0xff);
+
+      rp++;
+   }
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+      rp -= bpp;
+      pp -= bpp;
+
+      vec_ld_unaligned(pp_vec,pp);
+      rp_vec = vec_ld(0,rp);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop  > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+  const png_byte bpp = 3;
+
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned char pp_part_vec;
+  vector unsigned char rp_part_vec;
+  vector unsigned char avg_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  for (i = 0; i < bpp; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        ((int)(*pp++) / 2 )) & 0xff);
+
+     rp++;
+  }
+
+  /* Altivec operations require 16-byte aligned data
+   * but input can be unaligned. So we calculate
+   * unaligned part as usual.
+   */
+  for (i = 0; i < unaligned_top; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+     rp++;
+  }
+
+  /* Using SIMD while we can */
+  while( istop >= 16 )
+  {
+     for(i=0;i < bpp ; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+     rp -= bpp;
+     pp -= bpp;
+
+     vec_ld_unaligned(pp_vec,pp);
+     rp_vec = vec_ld(0,rp);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED4_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+     rp++;
+  }
+
+  if(istop  > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+}
+
+/* Bytewise c ? t : e. */
+#define if_then_else(c,t,e) vec_sel(e,t,c)
+
+#define vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp) {\
+      c = *(pp - bpp);\
+      a = *(rp - bpp);\
+      b = *pp++;\
+      p = b - c;\
+      pc = a - c;\
+      pa = vsx_abs(p);\
+      pb = vsx_abs(pc);\
+      pc = vsx_abs(p + pc);\
+      if (pb < pa) pa = pb, a = b;\
+      if (pc < pa) a = c;\
+      a += *rp;\
+      *rp++ = (png_byte)a;\
+      }
+
+void png_read_filter_row_paeth4_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   int a, b, c, pa, pb, pc, p;
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+   vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   /* Process the first pixel in the row completely (this is the same as 'up'
+    * because there is only one candidate predictor for the first row).
+    */
+   for(i = 0; i < bpp ; i++)
+   {
+      *rp = (png_byte)( *rp + *pp);
+      rp++;
+      pp++;
+   }
+
+   for(i = 0; i < unaligned_top ; i++)
+   {
+      vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+   }
+
+   while( istop >= 16)
+   {
+      for(i = 0; i < bpp ; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+
+      rp -= bpp;
+      pp -= bpp;
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_4),1,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_4),2,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_4),3,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,4)));
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+}
+
+void png_read_filter_row_paeth3_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+  const png_byte bpp = 3;
+
+  int a, b, c, pa, pb, pc, p;
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+  vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  /* Process the first pixel in the row completely (this is the same as 'up'
+   * because there is only one candidate predictor for the first row).
+   */
+  for(i = 0; i < bpp ; i++)
+  {
+     *rp = (png_byte)( *rp + *pp);
+     rp++;
+     pp++;
+  }
+
+  for(i = 0; i < unaligned_top ; i++)
+  {
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  while( istop >= 16)
+  {
+     for(i = 0; i < bpp ; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+
+     rp -= bpp;
+     pp -= bpp;
+     rp_vec = vec_ld(0,rp);
+     vec_ld_unaligned(pp_vec,pp);
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_3),1,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_3),2,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_3),3,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED4_3),4,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,4,3)));
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  if(istop > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+}
+
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* PNG_POWERPC_VSX_IMPLEMENTATION == 1 (intrinsics) */
+#endif /* READ */
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libpng/powerpc/powerpc_init.c	2020-04-08 22:46:36.164199240 +0000
@@ -0,0 +1,125 @@
+
+/* powerpc_init.c - POWERPC optimised filter functions
+ *
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ * Last changed in libpng 1.6.29 [March 16, 2017]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
+ * called.
+ */
+#define _POSIX_SOURCE 1
+
+#include <stdio.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+#if PNG_POWERPC_VSX_OPT > 0
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED /* Do run-time checks */
+/* WARNING: it is strongly recommended that you do not build libpng with
+ * run-time checks for CPU features if at all possible.  In the case of the PowerPC
+ * VSX instructions there is no processor-specific way of detecting the
+ * presence of the required support, therefore run-time detection is extremely
+ * OS specific.
+ *
+ * You may set the macro PNG_POWERPC_VSX_FILE to the file name of file containing
+ * a fragment of C source code which defines the png_have_vsx function.  There
+ * are a number of implementations in contrib/powerpc-vsx, but the only one that
+ * has partial support is contrib/powerpc-vsx/linux.c - a generic Linux
+ * implementation which reads /proc/cpufino.
+ */
+#ifndef PNG_POWERPC_VSX_FILE
+#  ifdef __linux__
+#     define  PNG_POWERPC_VSX_FILE "contrib/powerpc-vsx/linux_aux.c"
+#  endif
+#endif
+
+#ifdef PNG_POWERPC_VSX_FILE
+
+#include <signal.h> /* for sig_atomic_t */
+static int png_have_vsx(png_structp png_ptr);
+#include PNG_POWERPC_VSX_FILE
+
+#else  /* PNG_POWERPC_VSX_FILE */
+#  error "PNG_POWERPC_VSX_FILE undefined: no support for run-time POWERPC VSX checks"
+#endif /* PNG_POWERPC_VSX_FILE */
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+void
+png_init_filter_functions_vsx(png_structp pp, unsigned int bpp)
+{
+   /* The switch statement is compiled in for POWERPC_VSX_API, the call to
+    * png_have_vsx is compiled in for POWERPC_VSX_CHECK. If both are defined
+    * the check is only performed if the API has not set the PowerPC option on
+    * or off explicitly. In this case the check controls what happens.
+    */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+   switch ((pp->options >> PNG_POWERPC_VSX) & 3)
+   {
+      case PNG_OPTION_UNSET:
+         /* Allow the run-time check to execute if it has been enabled -
+          * thus both API and CHECK can be turned on.  If it isn't supported
+          * this case will fall through to the 'default' below, which just
+          * returns.
+          */
+#endif /* PNG_POWERPC_VSX_API_SUPPORTED */
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED
+         {
+            static volatile sig_atomic_t no_vsx = -1; /* not checked */
+
+            if (no_vsx < 0)
+               no_vsx = !png_have_vsx(pp);
+
+            if (no_vsx)
+               return;
+         }
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+         break;
+#endif
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+      default: /* OFF or INVALID */
+         return;
+
+      case PNG_OPTION_ON:
+         /* Option turned on */
+         break;
+   }
+#endif
+
+   /* IMPORTANT: any new internal functions used here must be declared using
+    * PNG_INTERNAL_FUNCTION in ../pngpriv.h.  This is required so that the
+    * 'prefix' option to configure works:
+    *
+    *    ./configure --with-libpng-prefix=foobar_
+    *
+    * Verify you have got this right by running the above command, doing a build
+    * and examining pngprefix.h; it must contain a #define for every external
+    * function you add.  (Notice that this happens automatically for the
+    * initialization function.)
+    */
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_vsx;
+
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth3_vsx;
+   }
+
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth4_vsx;
+   }
+}
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* READ */
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/BUILD.gn	2020-04-08 22:56:08.836574584 +0000
@@ -2,8 +2,8 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-import("//build/config/arm.gni")
 import("//build/config/android/config.gni")
+import("//build/config/arm.gni")
 import("//build/config/linux/pkg_config.gni")
 import("//build/config/sanitizers/sanitizers.gni")
 import("//build/shim_headers.gni")
@@ -233,6 +233,8 @@
       sources = libvpx_srcs_x86_avx512
     } else if (current_cpu == "x64") {
       sources = libvpx_srcs_x86_64_avx512
+    } else if (current_cpu == "ppc64") {
+      sources = libvpx_srcs_ppc64
     }
   }
 }
@@ -387,9 +389,13 @@
 
 group("libvpx") {
   if (use_system_libvpx) {
-    deps = [ ":libvpx_shim" ]
+    deps = [
+      ":libvpx_shim",
+    ]
     public_configs = [ ":system_libvpx" ]
   } else {
-    public_deps = [ ":bundled_libvpx" ]
+    public_deps = [
+      ":bundled_libvpx",
+    ]
   }
 }
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/generate_gni.sh	2020-04-08 23:09:59.388722853 +0000
@@ -350,6 +350,7 @@
 gen_config_files linux/arm64 "--target=armv8-linux-gcc ${all_platforms}"
 gen_config_files linux/mipsel "--target=mips32-linux-gcc ${all_platforms}"
 gen_config_files linux/mips64el "--target=mips64-linux-gcc ${all_platforms}"
+gen_config_files linux/ppc64 "--target=ppc64le-linux-gcc ${all_platforms}"
 gen_config_files linux/generic "--target=generic-gnu $HIGHBD ${all_platforms}"
 gen_config_files win/ia32 "--target=x86-win32-vs12 ${all_platforms} ${x86_platforms}"
 gen_config_files win/x64 "--target=x86_64-win64-vs12 ${all_platforms} ${x86_platforms}"
@@ -372,6 +373,7 @@
 lint_config linux/arm64
 lint_config linux/mipsel
 lint_config linux/mips64el
+lint_config linux/ppc64
 lint_config linux/generic
 lint_config win/ia32
 lint_config win/x64
@@ -395,6 +397,7 @@
 gen_rtcd_header linux/arm64 armv8
 gen_rtcd_header linux/mipsel mipsel
 gen_rtcd_header linux/mips64el mips64el
+gen_rtcd_header linux/ppc64 ppc
 gen_rtcd_header linux/generic generic
 gen_rtcd_header win/ia32 x86
 gen_rtcd_header win/x64 x86_64
@@ -464,6 +467,13 @@
 
   echo "MIPS64 source list is identical to MIPS source list. No need to generate it."
 
+  echo "Generate ppc64 source list."
+  config=$(print_config_basic linux/ppc64)
+  make_clean
+  make libvpx_srcs.txt target=libs $config > /dev/null
+  convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_ppc64
+
+
   echo "Generate NaCl source list."
   config=$(print_config_basic nacl)
   make_clean
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/libvpx_srcs.gni	2020-04-08 22:56:08.866571047 +0000
@@ -2884,6 +2884,364 @@
   "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.h",
 ]
 libvpx_srcs_mips_assembly = []
+libvpx_srcs_ppc64 = [
+  "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/blockd.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/blockd.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/coefupdateprobs.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/common.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/copy_c.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/default_coef_probs.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/dequantize.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropy.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropy.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymode.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymode.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymv.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/extend.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/extend.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/filter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/filter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/findnearmv.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/findnearmv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/generic/systemdependent.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/header.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/idct_blk.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/idctllm.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/invtrans.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/loopfilter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/loopfilter_filters.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/mbpitch.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/mfqe.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/modecont.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/modecont.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/mv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyx.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyxc_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyxd.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/postproc.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/postproc.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/ppflags.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/quant_common.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/quant_common.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconinter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconinter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra4x4.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra4x4.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/rtcd.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/setupintrarecon.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/setupintrarecon.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/swapyv12buffer.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/swapyv12buffer.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/systemdependent.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/threading.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/treecoder.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/treecoder.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_entropymodedata.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/dboolhuff.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/dboolhuff.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodemv.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodemv.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decoderthreading.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/detokenize.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/detokenize.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/onyxd_if.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/onyxd_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/threading.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/treereader.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/bitstream.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/bitstream.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/block.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/boolhuff.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/boolhuff.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct_value_cost.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct_value_tokens.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/defaultcoefcounts.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/denoising.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/denoising.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeintra.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeintra.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemb.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemb.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemv.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemv.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ethreading.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ethreading.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/firstpass.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/lookahead.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/lookahead.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mcomp.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mcomp.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/modecosts.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/modecosts.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mr_dissim.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mr_dissim.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/onyx_if.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/onyx_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/pickinter.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/pickinter.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/picklpf.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/picklpf.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/quantize.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ratectrl.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ratectrl.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/rdopt.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/rdopt.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/segmentation.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/segmentation.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/tokenize.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/tokenize.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/treewriter.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/treewriter.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/vp8_quantize.c",
+  "//third_party/libvpx/source/libvpx/vp8/vp8_cx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp8/vp8_dx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/ppc/vp9_idct_vsx.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_alloccommon.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_alloccommon.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_blockd.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_blockd.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common_data.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common_data.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropy.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropy.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymode.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymode.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymv.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymv.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_enums.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_filter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_filter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_frame_buffers.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_frame_buffers.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_idct.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_idct.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_loopfilter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mfqe.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mfqe.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mv.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mvref_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mvref_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_onyxc_int.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_postproc.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_postproc.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_ppflags.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_pred_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_pred_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_quant_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_quant_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconinter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconinter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconintra.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconintra.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scale.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scale.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scan.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scan.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_seg_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_seg_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_thread_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_thread_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_tile_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_tile_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodemv.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodemv.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decoder.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decoder.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_detokenize.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_detokenize.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_dsubexp.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_dsubexp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/ppc/vp9_quantize_vsx.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_alt_ref_aq.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_alt_ref_aq.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_360.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_360.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_complexity.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_complexity.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_cyclicrefresh.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_cyclicrefresh.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_variance.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_variance.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_bitstream.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_bitstream.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_block.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_context_tree.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_context_tree.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_cost.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_cost.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_dct.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_denoiser.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_denoiser.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemb.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemb.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemv.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemv.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encoder.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encoder.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ethread.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ethread.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_extend.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_extend.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_firstpass.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_frame_scale.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_job_queue.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_lookahead.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_lookahead.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mbgraph.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mcomp.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mcomp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_multi_thread.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_multi_thread.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_noise_estimate.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_noise_estimate.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_picklpf.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_picklpf.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_pickmode.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_pickmode.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_quantize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_quantize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ratectrl.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ratectrl.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rd.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rd.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rdopt.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rdopt.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_resize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_resize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_segmentation.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_segmentation.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_speed_features.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_speed_features.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_subexp.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_subexp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_svc_layercontext.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_svc_layercontext.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_temporal_filter.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_tokenize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_tokenize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_treewriter.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_treewriter.h",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_cx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_dx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_dx_iface.h",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_iface_common.h",
+  "//third_party/libvpx/source/libvpx/vpx/internal/vpx_codec_internal.h",
+  "//third_party/libvpx/source/libvpx/vpx/src/svc_encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_codec.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_decoder.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_encoder.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_image.c",
+  "//third_party/libvpx/source/libvpx/vpx/svc_context.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8cx.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8dx.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_codec.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_decoder.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_encoder.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_frame_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_image.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_integer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/add_noise.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/avg.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader_buffer.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter_buffer.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/deblock.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/fwd_txfm.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/fwd_txfm.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/intrapred.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/inv_txfm.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/inv_txfm.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/postproc.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/bitdepth_conversion_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/deblock_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/fdct32x32_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/hadamard_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/intrapred_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/inv_txfm_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/quantize_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/sad_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/subtract_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/transpose_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/txfm_common_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/types_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/variance_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/vpx_convolve_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/prob.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/prob.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/psnr.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/psnr.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/quantize.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/quantize.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/sad.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/subtract.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/sum_squares.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/txfm_common.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/variance.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/variance.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_convolve.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_convolve.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_dsp_common.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_dsp_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_filter.h",
+  "//third_party/libvpx/source/libvpx/vpx_mem/include/vpx_mem_intrnl.h",
+  "//third_party/libvpx/source/libvpx/vpx_mem/vpx_mem.c",
+  "//third_party/libvpx/source/libvpx/vpx_mem/vpx_mem.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/bitops.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/emmintrin_compat.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem_ops.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem_ops_aligned.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/msvc.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/ppc.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c",
+  "//third_party/libvpx/source/libvpx/vpx_ports/system_state.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/vpx_once.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/vpx_timer.h",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/gen_scalers.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/vpx_scale.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/yv12config.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/yv12extend.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/vpx_scale.h",
+  "//third_party/libvpx/source/libvpx/vpx_scale/vpx_scale_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/yv12config.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/endian_inl.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_atomics.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_thread.c",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_thread.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.c",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.h",
+]
+libvpx_srcs_ppc64_assembly = []
 libvpx_srcs_nacl = [
   "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.c",
   "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.h",
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/README.chromium qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/README.chromium
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/README.chromium	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/README.chromium	2020-04-08 22:56:08.876569867 +0000
@@ -5,9 +5,9 @@
 License File: source/libvpx/LICENSE
 Security Critical: yes
 
-Date: Monday July 30 2018
+Date: Wednesday April 08 2020
 Branch: m69-3497
-Commit: b0dfe4e5c1dd485a61546ad238b14de7775eb24f
+Commit: a8e644866ce9bbd7739dc4d2ac8e9f3e5ea3fd48
 
 Description:
 Contains the sources used to compile libvpx binaries used by Google Chrome and
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp8_rtcd.h	2020-04-08 22:55:45.039380785 +0000
@@ -0,0 +1,354 @@
+// This file is generated. Do not edit.
+#ifndef VP8_RTCD_H_
+#define VP8_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP8
+ */
+
+struct blockd;
+struct macroblockd;
+struct loop_filter_info;
+
+/* Encoder forward decls */
+struct block;
+struct macroblock;
+struct variance_vtable;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_bilinear_predict16x16_c(unsigned char* src,
+                                 int src_pitch,
+                                 int xofst,
+                                 int yofst,
+                                 unsigned char* dst,
+                                 int dst_pitch);
+#define vp8_bilinear_predict16x16 vp8_bilinear_predict16x16_c
+
+void vp8_bilinear_predict4x4_c(unsigned char* src,
+                               int src_pitch,
+                               int xofst,
+                               int yofst,
+                               unsigned char* dst,
+                               int dst_pitch);
+#define vp8_bilinear_predict4x4 vp8_bilinear_predict4x4_c
+
+void vp8_bilinear_predict8x4_c(unsigned char* src,
+                               int src_pitch,
+                               int xofst,
+                               int yofst,
+                               unsigned char* dst,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x4 vp8_bilinear_predict8x4_c
+
+void vp8_bilinear_predict8x8_c(unsigned char* src,
+                               int src_pitch,
+                               int xofst,
+                               int yofst,
+                               unsigned char* dst,
+                               int dst_pitch);
+#define vp8_bilinear_predict8x8 vp8_bilinear_predict8x8_c
+
+void vp8_blend_b_c(unsigned char* y,
+                   unsigned char* u,
+                   unsigned char* v,
+                   int y1,
+                   int u1,
+                   int v1,
+                   int alpha,
+                   int stride);
+#define vp8_blend_b vp8_blend_b_c
+
+void vp8_blend_mb_inner_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y1,
+                          int u1,
+                          int v1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_inner vp8_blend_mb_inner_c
+
+void vp8_blend_mb_outer_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int y1,
+                          int u1,
+                          int v1,
+                          int alpha,
+                          int stride);
+#define vp8_blend_mb_outer vp8_blend_mb_outer_c
+
+int vp8_block_error_c(short* coeff, short* dqcoeff);
+#define vp8_block_error vp8_block_error_c
+
+void vp8_copy_mem16x16_c(unsigned char* src,
+                         int src_pitch,
+                         unsigned char* dst,
+                         int dst_pitch);
+#define vp8_copy_mem16x16 vp8_copy_mem16x16_c
+
+void vp8_copy_mem8x4_c(unsigned char* src,
+                       int src_pitch,
+                       unsigned char* dst,
+                       int dst_pitch);
+#define vp8_copy_mem8x4 vp8_copy_mem8x4_c
+
+void vp8_copy_mem8x8_c(unsigned char* src,
+                       int src_pitch,
+                       unsigned char* dst,
+                       int dst_pitch);
+#define vp8_copy_mem8x8 vp8_copy_mem8x8_c
+
+void vp8_dc_only_idct_add_c(short input,
+                            unsigned char* pred,
+                            int pred_stride,
+                            unsigned char* dst,
+                            int dst_stride);
+#define vp8_dc_only_idct_add vp8_dc_only_idct_add_c
+
+int vp8_denoiser_filter_c(unsigned char* mc_running_avg_y,
+                          int mc_avg_y_stride,
+                          unsigned char* running_avg_y,
+                          int avg_y_stride,
+                          unsigned char* sig,
+                          int sig_stride,
+                          unsigned int motion_magnitude,
+                          int increase_denoising);
+#define vp8_denoiser_filter vp8_denoiser_filter_c
+
+int vp8_denoiser_filter_uv_c(unsigned char* mc_running_avg,
+                             int mc_avg_stride,
+                             unsigned char* running_avg,
+                             int avg_stride,
+                             unsigned char* sig,
+                             int sig_stride,
+                             unsigned int motion_magnitude,
+                             int increase_denoising);
+#define vp8_denoiser_filter_uv vp8_denoiser_filter_uv_c
+
+void vp8_dequant_idct_add_c(short* input,
+                            short* dq,
+                            unsigned char* output,
+                            int stride);
+#define vp8_dequant_idct_add vp8_dequant_idct_add_c
+
+void vp8_dequant_idct_add_uv_block_c(short* q,
+                                     short* dq,
+                                     unsigned char* dst_u,
+                                     unsigned char* dst_v,
+                                     int stride,
+                                     char* eobs);
+#define vp8_dequant_idct_add_uv_block vp8_dequant_idct_add_uv_block_c
+
+void vp8_dequant_idct_add_y_block_c(short* q,
+                                    short* dq,
+                                    unsigned char* dst,
+                                    int stride,
+                                    char* eobs);
+#define vp8_dequant_idct_add_y_block vp8_dequant_idct_add_y_block_c
+
+void vp8_dequantize_b_c(struct blockd*, short* dqc);
+#define vp8_dequantize_b vp8_dequantize_b_c
+
+int vp8_diamond_search_sad_c(struct macroblock* x,
+                             struct block* b,
+                             struct blockd* d,
+                             union int_mv* ref_mv,
+                             union int_mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             struct variance_vtable* fn_ptr,
+                             int* mvcost[2],
+                             union int_mv* center_mv);
+#define vp8_diamond_search_sad vp8_diamond_search_sad_c
+
+void vp8_fast_quantize_b_c(struct block*, struct blockd*);
+#define vp8_fast_quantize_b vp8_fast_quantize_b_c
+
+void vp8_filter_by_weight16x16_c(unsigned char* src,
+                                 int src_stride,
+                                 unsigned char* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp8_filter_by_weight16x16 vp8_filter_by_weight16x16_c
+
+void vp8_filter_by_weight4x4_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight4x4 vp8_filter_by_weight4x4_c
+
+void vp8_filter_by_weight8x8_c(unsigned char* src,
+                               int src_stride,
+                               unsigned char* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp8_filter_by_weight8x8 vp8_filter_by_weight8x8_c
+
+int vp8_full_search_sad_c(struct macroblock* x,
+                          struct block* b,
+                          struct blockd* d,
+                          union int_mv* ref_mv,
+                          int sad_per_bit,
+                          int distance,
+                          struct variance_vtable* fn_ptr,
+                          int* mvcost[2],
+                          union int_mv* center_mv);
+#define vp8_full_search_sad vp8_full_search_sad_c
+
+void vp8_loop_filter_bh_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int ystride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bh vp8_loop_filter_bh_c
+
+void vp8_loop_filter_bv_c(unsigned char* y,
+                          unsigned char* u,
+                          unsigned char* v,
+                          int ystride,
+                          int uv_stride,
+                          struct loop_filter_info* lfi);
+#define vp8_loop_filter_bv vp8_loop_filter_bv_c
+
+void vp8_loop_filter_mbh_c(unsigned char* y,
+                           unsigned char* u,
+                           unsigned char* v,
+                           int ystride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbh vp8_loop_filter_mbh_c
+
+void vp8_loop_filter_mbv_c(unsigned char* y,
+                           unsigned char* u,
+                           unsigned char* v,
+                           int ystride,
+                           int uv_stride,
+                           struct loop_filter_info* lfi);
+#define vp8_loop_filter_mbv vp8_loop_filter_mbv_c
+
+void vp8_loop_filter_bhs_c(unsigned char* y,
+                           int ystride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bh vp8_loop_filter_bhs_c
+
+void vp8_loop_filter_bvs_c(unsigned char* y,
+                           int ystride,
+                           const unsigned char* blimit);
+#define vp8_loop_filter_simple_bv vp8_loop_filter_bvs_c
+
+void vp8_loop_filter_simple_horizontal_edge_c(unsigned char* y,
+                                              int ystride,
+                                              const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbh vp8_loop_filter_simple_horizontal_edge_c
+
+void vp8_loop_filter_simple_vertical_edge_c(unsigned char* y,
+                                            int ystride,
+                                            const unsigned char* blimit);
+#define vp8_loop_filter_simple_mbv vp8_loop_filter_simple_vertical_edge_c
+
+int vp8_mbblock_error_c(struct macroblock* mb, int dc);
+#define vp8_mbblock_error vp8_mbblock_error_c
+
+int vp8_mbuverror_c(struct macroblock* mb);
+#define vp8_mbuverror vp8_mbuverror_c
+
+int vp8_refining_search_sad_c(struct macroblock* x,
+                              struct block* b,
+                              struct blockd* d,
+                              union int_mv* ref_mv,
+                              int sad_per_bit,
+                              int distance,
+                              struct variance_vtable* fn_ptr,
+                              int* mvcost[2],
+                              union int_mv* center_mv);
+#define vp8_refining_search_sad vp8_refining_search_sad_c
+
+void vp8_regular_quantize_b_c(struct block*, struct blockd*);
+#define vp8_regular_quantize_b vp8_regular_quantize_b_c
+
+void vp8_short_fdct4x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct4x4 vp8_short_fdct4x4_c
+
+void vp8_short_fdct8x4_c(short* input, short* output, int pitch);
+#define vp8_short_fdct8x4 vp8_short_fdct8x4_c
+
+void vp8_short_idct4x4llm_c(short* input,
+                            unsigned char* pred,
+                            int pitch,
+                            unsigned char* dst,
+                            int dst_stride);
+#define vp8_short_idct4x4llm vp8_short_idct4x4llm_c
+
+void vp8_short_inv_walsh4x4_c(short* input, short* output);
+#define vp8_short_inv_walsh4x4 vp8_short_inv_walsh4x4_c
+
+void vp8_short_inv_walsh4x4_1_c(short* input, short* output);
+#define vp8_short_inv_walsh4x4_1 vp8_short_inv_walsh4x4_1_c
+
+void vp8_short_walsh4x4_c(short* input, short* output, int pitch);
+#define vp8_short_walsh4x4 vp8_short_walsh4x4_c
+
+void vp8_sixtap_predict16x16_c(unsigned char* src,
+                               int src_pitch,
+                               int xofst,
+                               int yofst,
+                               unsigned char* dst,
+                               int dst_pitch);
+#define vp8_sixtap_predict16x16 vp8_sixtap_predict16x16_c
+
+void vp8_sixtap_predict4x4_c(unsigned char* src,
+                             int src_pitch,
+                             int xofst,
+                             int yofst,
+                             unsigned char* dst,
+                             int dst_pitch);
+#define vp8_sixtap_predict4x4 vp8_sixtap_predict4x4_c
+
+void vp8_sixtap_predict8x4_c(unsigned char* src,
+                             int src_pitch,
+                             int xofst,
+                             int yofst,
+                             unsigned char* dst,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x4 vp8_sixtap_predict8x4_c
+
+void vp8_sixtap_predict8x8_c(unsigned char* src,
+                             int src_pitch,
+                             int xofst,
+                             int yofst,
+                             unsigned char* dst,
+                             int dst_pitch);
+#define vp8_sixtap_predict8x8 vp8_sixtap_predict8x8_c
+
+void vp8_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vp9_rtcd.h	2020-04-08 22:55:45.119371352 +0000
@@ -0,0 +1,217 @@
+// This file is generated. Do not edit.
+#ifndef VP9_RTCD_H_
+#define VP9_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * VP9
+ */
+
+#include "vp9/common/vp9_common.h"
+#include "vp9/common/vp9_enums.h"
+#include "vp9/common/vp9_filter.h"
+#include "vpx/vpx_integer.h"
+
+struct macroblockd;
+
+/* Encoder forward decls */
+struct macroblock;
+struct vp9_variance_vtable;
+struct search_site_config;
+struct mv;
+union int_mv;
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int64_t vp9_block_error_c(const tran_low_t* coeff,
+                          const tran_low_t* dqcoeff,
+                          intptr_t block_size,
+                          int64_t* ssz);
+#define vp9_block_error vp9_block_error_c
+
+int64_t vp9_block_error_fp_c(const tran_low_t* coeff,
+                             const tran_low_t* dqcoeff,
+                             int block_size);
+#define vp9_block_error_fp vp9_block_error_fp_c
+
+int vp9_denoiser_filter_c(const uint8_t* sig,
+                          int sig_stride,
+                          const uint8_t* mc_avg,
+                          int mc_avg_stride,
+                          uint8_t* avg,
+                          int avg_stride,
+                          int increase_denoising,
+                          BLOCK_SIZE bs,
+                          int motion_magnitude);
+#define vp9_denoiser_filter vp9_denoiser_filter_c
+
+int vp9_diamond_search_sad_c(const struct macroblock* x,
+                             const struct search_site_config* cfg,
+                             struct mv* ref_mv,
+                             struct mv* best_mv,
+                             int search_param,
+                             int sad_per_bit,
+                             int* num00,
+                             const struct vp9_variance_vtable* fn_ptr,
+                             const struct mv* center_mv);
+#define vp9_diamond_search_sad vp9_diamond_search_sad_c
+
+void vp9_fdct8x8_quant_c(const int16_t* input,
+                         int stride,
+                         tran_low_t* coeff_ptr,
+                         intptr_t n_coeffs,
+                         int skip_block,
+                         const int16_t* round_ptr,
+                         const int16_t* quant_ptr,
+                         tran_low_t* qcoeff_ptr,
+                         tran_low_t* dqcoeff_ptr,
+                         const int16_t* dequant_ptr,
+                         uint16_t* eob_ptr,
+                         const int16_t* scan,
+                         const int16_t* iscan);
+#define vp9_fdct8x8_quant vp9_fdct8x8_quant_c
+
+void vp9_fht16x16_c(const int16_t* input,
+                    tran_low_t* output,
+                    int stride,
+                    int tx_type);
+#define vp9_fht16x16 vp9_fht16x16_c
+
+void vp9_fht4x4_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht4x4 vp9_fht4x4_c
+
+void vp9_fht8x8_c(const int16_t* input,
+                  tran_low_t* output,
+                  int stride,
+                  int tx_type);
+#define vp9_fht8x8 vp9_fht8x8_c
+
+void vp9_filter_by_weight16x16_c(const uint8_t* src,
+                                 int src_stride,
+                                 uint8_t* dst,
+                                 int dst_stride,
+                                 int src_weight);
+#define vp9_filter_by_weight16x16 vp9_filter_by_weight16x16_c
+
+void vp9_filter_by_weight8x8_c(const uint8_t* src,
+                               int src_stride,
+                               uint8_t* dst,
+                               int dst_stride,
+                               int src_weight);
+#define vp9_filter_by_weight8x8 vp9_filter_by_weight8x8_c
+
+void vp9_fwht4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vp9_fwht4x4 vp9_fwht4x4_c
+
+void vp9_iht16x16_256_add_c(const tran_low_t* input,
+                            uint8_t* output,
+                            int pitch,
+                            int tx_type);
+void vp9_iht16x16_256_add_vsx(const tran_low_t* input,
+                              uint8_t* output,
+                              int pitch,
+                              int tx_type);
+#define vp9_iht16x16_256_add vp9_iht16x16_256_add_vsx
+
+void vp9_iht4x4_16_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+void vp9_iht4x4_16_add_vsx(const tran_low_t* input,
+                           uint8_t* dest,
+                           int stride,
+                           int tx_type);
+#define vp9_iht4x4_16_add vp9_iht4x4_16_add_vsx
+
+void vp9_iht8x8_64_add_c(const tran_low_t* input,
+                         uint8_t* dest,
+                         int stride,
+                         int tx_type);
+void vp9_iht8x8_64_add_vsx(const tran_low_t* input,
+                           uint8_t* dest,
+                           int stride,
+                           int tx_type);
+#define vp9_iht8x8_64_add vp9_iht8x8_64_add_vsx
+
+void vp9_quantize_fp_c(const tran_low_t* coeff_ptr,
+                       intptr_t n_coeffs,
+                       int skip_block,
+                       const int16_t* round_ptr,
+                       const int16_t* quant_ptr,
+                       tran_low_t* qcoeff_ptr,
+                       tran_low_t* dqcoeff_ptr,
+                       const int16_t* dequant_ptr,
+                       uint16_t* eob_ptr,
+                       const int16_t* scan,
+                       const int16_t* iscan);
+void vp9_quantize_fp_vsx(const tran_low_t* coeff_ptr,
+                         intptr_t n_coeffs,
+                         int skip_block,
+                         const int16_t* round_ptr,
+                         const int16_t* quant_ptr,
+                         tran_low_t* qcoeff_ptr,
+                         tran_low_t* dqcoeff_ptr,
+                         const int16_t* dequant_ptr,
+                         uint16_t* eob_ptr,
+                         const int16_t* scan,
+                         const int16_t* iscan);
+#define vp9_quantize_fp vp9_quantize_fp_vsx
+
+void vp9_quantize_fp_32x32_c(const tran_low_t* coeff_ptr,
+                             intptr_t n_coeffs,
+                             int skip_block,
+                             const int16_t* round_ptr,
+                             const int16_t* quant_ptr,
+                             tran_low_t* qcoeff_ptr,
+                             tran_low_t* dqcoeff_ptr,
+                             const int16_t* dequant_ptr,
+                             uint16_t* eob_ptr,
+                             const int16_t* scan,
+                             const int16_t* iscan);
+void vp9_quantize_fp_32x32_vsx(const tran_low_t* coeff_ptr,
+                               intptr_t n_coeffs,
+                               int skip_block,
+                               const int16_t* round_ptr,
+                               const int16_t* quant_ptr,
+                               tran_low_t* qcoeff_ptr,
+                               tran_low_t* dqcoeff_ptr,
+                               const int16_t* dequant_ptr,
+                               uint16_t* eob_ptr,
+                               const int16_t* scan,
+                               const int16_t* iscan);
+#define vp9_quantize_fp_32x32 vp9_quantize_fp_32x32_vsx
+
+void vp9_scale_and_extend_frame_c(const struct yv12_buffer_config* src,
+                                  struct yv12_buffer_config* dst,
+                                  INTERP_FILTER filter_type,
+                                  int phase_scaler);
+#define vp9_scale_and_extend_frame vp9_scale_and_extend_frame_c
+
+void vp9_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.asm	2020-04-08 22:55:24.591792182 +0000
@@ -0,0 +1,89 @@
+@ This file was created from a .asm file
+@  using the ads2gas.pl script.
+	.equ DO1STROUNDING, 0
+.equ ARCH_ARM ,  0
+.equ ARCH_MIPS ,  0
+.equ ARCH_X86 ,  0
+.equ ARCH_X86_64 ,  0
+.equ ARCH_PPC ,  1
+.equ HAVE_NEON ,  0
+.equ HAVE_NEON_ASM ,  0
+.equ HAVE_MIPS32 ,  0
+.equ HAVE_DSPR2 ,  0
+.equ HAVE_MSA ,  0
+.equ HAVE_MIPS64 ,  0
+.equ HAVE_MMX ,  0
+.equ HAVE_SSE ,  0
+.equ HAVE_SSE2 ,  0
+.equ HAVE_SSE3 ,  0
+.equ HAVE_SSSE3 ,  0
+.equ HAVE_SSE4_1 ,  0
+.equ HAVE_AVX ,  0
+.equ HAVE_AVX2 ,  0
+.equ HAVE_AVX512 ,  0
+.equ HAVE_VSX ,  1
+.equ HAVE_MMI ,  0
+.equ HAVE_VPX_PORTS ,  1
+.equ HAVE_PTHREAD_H ,  1
+.equ HAVE_UNISTD_H ,  0
+.equ CONFIG_DEPENDENCY_TRACKING ,  1
+.equ CONFIG_EXTERNAL_BUILD ,  1
+.equ CONFIG_INSTALL_DOCS ,  0
+.equ CONFIG_INSTALL_BINS ,  1
+.equ CONFIG_INSTALL_LIBS ,  1
+.equ CONFIG_INSTALL_SRCS ,  0
+.equ CONFIG_DEBUG ,  0
+.equ CONFIG_GPROF ,  0
+.equ CONFIG_GCOV ,  0
+.equ CONFIG_RVCT ,  0
+.equ CONFIG_GCC ,  1
+.equ CONFIG_MSVS ,  0
+.equ CONFIG_PIC ,  0
+.equ CONFIG_BIG_ENDIAN ,  0
+.equ CONFIG_CODEC_SRCS ,  0
+.equ CONFIG_DEBUG_LIBS ,  0
+.equ CONFIG_DEQUANT_TOKENS ,  0
+.equ CONFIG_DC_RECON ,  0
+.equ CONFIG_RUNTIME_CPU_DETECT ,  0
+.equ CONFIG_POSTPROC ,  1
+.equ CONFIG_VP9_POSTPROC ,  1
+.equ CONFIG_MULTITHREAD ,  1
+.equ CONFIG_INTERNAL_STATS ,  0
+.equ CONFIG_VP8_ENCODER ,  1
+.equ CONFIG_VP8_DECODER ,  1
+.equ CONFIG_VP9_ENCODER ,  1
+.equ CONFIG_VP9_DECODER ,  1
+.equ CONFIG_VP8 ,  1
+.equ CONFIG_VP9 ,  1
+.equ CONFIG_ENCODERS ,  1
+.equ CONFIG_DECODERS ,  1
+.equ CONFIG_STATIC_MSVCRT ,  0
+.equ CONFIG_SPATIAL_RESAMPLING ,  1
+.equ CONFIG_REALTIME_ONLY ,  1
+.equ CONFIG_ONTHEFLY_BITPACKING ,  0
+.equ CONFIG_ERROR_CONCEALMENT ,  0
+.equ CONFIG_SHARED ,  0
+.equ CONFIG_STATIC ,  1
+.equ CONFIG_SMALL ,  0
+.equ CONFIG_POSTPROC_VISUALIZER ,  0
+.equ CONFIG_OS_SUPPORT ,  1
+.equ CONFIG_UNIT_TESTS ,  1
+.equ CONFIG_WEBM_IO ,  1
+.equ CONFIG_LIBYUV ,  1
+.equ CONFIG_DECODE_PERF_TESTS ,  0
+.equ CONFIG_ENCODE_PERF_TESTS ,  0
+.equ CONFIG_MULTI_RES_ENCODING ,  1
+.equ CONFIG_TEMPORAL_DENOISING ,  1
+.equ CONFIG_VP9_TEMPORAL_DENOISING ,  1
+.equ CONFIG_CONSISTENT_RECODE ,  0
+.equ CONFIG_COEFFICIENT_RANGE_CHECKING ,  0
+.equ CONFIG_VP9_HIGHBITDEPTH ,  0
+.equ CONFIG_BETTER_HW_COMPATIBILITY ,  0
+.equ CONFIG_EXPERIMENTAL ,  0
+.equ CONFIG_SIZE_LIMIT ,  1
+.equ CONFIG_ALWAYS_ADJUST_BPM ,  0
+.equ CONFIG_FP_MB_STATS ,  0
+.equ CONFIG_EMULATE_HARDWARE ,  0
+.equ DECODE_WIDTH_LIMIT ,  16384
+.equ DECODE_HEIGHT_LIMIT ,  16384
+	.section	.note.GNU-stack,"",%progbits
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.c	2020-04-08 22:55:24.591792182 +0000
@@ -0,0 +1,10 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+#include "vpx/vpx_codec.h"
+static const char* const cfg = "--target=ppc64le-linux-gcc --enable-external-build --enable-postproc --enable-multi-res-encoding --enable-temporal-denoising --enable-vp9-temporal-denoising --enable-vp9-postproc --size-limit=16384x16384 --enable-realtime-only --disable-install-docs";
+const char *vpx_codec_build_config(void) {return cfg;}
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_config.h	2020-04-08 22:55:24.591792182 +0000
@@ -0,0 +1,98 @@
+/* Copyright (c) 2011 The WebM project authors. All Rights Reserved. */
+/*  */
+/* Use of this source code is governed by a BSD-style license */
+/* that can be found in the LICENSE file in the root of the source */
+/* tree. An additional intellectual property rights grant can be found */
+/* in the file PATENTS.  All contributing project authors may */
+/* be found in the AUTHORS file in the root of the source tree. */
+/* This file automatically generated by configure. Do not edit! */
+#ifndef VPX_CONFIG_H
+#define VPX_CONFIG_H
+#define RESTRICT    
+#define INLINE      inline
+#define ARCH_ARM 0
+#define ARCH_MIPS 0
+#define ARCH_X86 0
+#define ARCH_X86_64 0
+#define ARCH_PPC 1
+#define HAVE_NEON 0
+#define HAVE_NEON_ASM 0
+#define HAVE_MIPS32 0
+#define HAVE_DSPR2 0
+#define HAVE_MSA 0
+#define HAVE_MIPS64 0
+#define HAVE_MMX 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSSE3 0
+#define HAVE_SSE4_1 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_VSX 1
+#define HAVE_MMI 0
+#define HAVE_VPX_PORTS 1
+#define HAVE_PTHREAD_H 1
+#define HAVE_UNISTD_H 0
+#define CONFIG_DEPENDENCY_TRACKING 1
+#define CONFIG_EXTERNAL_BUILD 1
+#define CONFIG_INSTALL_DOCS 0
+#define CONFIG_INSTALL_BINS 1
+#define CONFIG_INSTALL_LIBS 1
+#define CONFIG_INSTALL_SRCS 0
+#define CONFIG_DEBUG 0
+#define CONFIG_GPROF 0
+#define CONFIG_GCOV 0
+#define CONFIG_RVCT 0
+#define CONFIG_GCC 1
+#define CONFIG_MSVS 0
+#define CONFIG_PIC 0
+#define CONFIG_BIG_ENDIAN 0
+#define CONFIG_CODEC_SRCS 0
+#define CONFIG_DEBUG_LIBS 0
+#define CONFIG_DEQUANT_TOKENS 0
+#define CONFIG_DC_RECON 0
+#define CONFIG_RUNTIME_CPU_DETECT 0
+#define CONFIG_POSTPROC 1
+#define CONFIG_VP9_POSTPROC 1
+#define CONFIG_MULTITHREAD 1
+#define CONFIG_INTERNAL_STATS 0
+#define CONFIG_VP8_ENCODER 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP9_ENCODER 1
+#define CONFIG_VP9_DECODER 1
+#define CONFIG_VP8 1
+#define CONFIG_VP9 1
+#define CONFIG_ENCODERS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_STATIC_MSVCRT 0
+#define CONFIG_SPATIAL_RESAMPLING 1
+#define CONFIG_REALTIME_ONLY 1
+#define CONFIG_ONTHEFLY_BITPACKING 0
+#define CONFIG_ERROR_CONCEALMENT 0
+#define CONFIG_SHARED 0
+#define CONFIG_STATIC 1
+#define CONFIG_SMALL 0
+#define CONFIG_POSTPROC_VISUALIZER 0
+#define CONFIG_OS_SUPPORT 1
+#define CONFIG_UNIT_TESTS 1
+#define CONFIG_WEBM_IO 1
+#define CONFIG_LIBYUV 1
+#define CONFIG_DECODE_PERF_TESTS 0
+#define CONFIG_ENCODE_PERF_TESTS 0
+#define CONFIG_MULTI_RES_ENCODING 1
+#define CONFIG_TEMPORAL_DENOISING 1
+#define CONFIG_VP9_TEMPORAL_DENOISING 1
+#define CONFIG_CONSISTENT_RECODE 0
+#define CONFIG_COEFFICIENT_RANGE_CHECKING 0
+#define CONFIG_VP9_HIGHBITDEPTH 0
+#define CONFIG_BETTER_HW_COMPATIBILITY 0
+#define CONFIG_EXPERIMENTAL 0
+#define CONFIG_SIZE_LIMIT 1
+#define CONFIG_ALWAYS_ADJUST_BPM 0
+#define CONFIG_FP_MB_STATS 0
+#define CONFIG_EMULATE_HARDWARE 0
+#define DECODE_WIDTH_LIMIT 16384
+#define DECODE_HEIGHT_LIMIT 16384
+#endif /* VPX_CONFIG_H */
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_dsp_rtcd.h	2020-04-08 22:55:45.479328904 +0000
@@ -0,0 +1,2067 @@
+// This file is generated. Do not edit.
+#ifndef VPX_DSP_RTCD_H_
+#define VPX_DSP_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+/*
+ * DSP
+ */
+
+#include "vpx/vpx_integer.h"
+#include "vpx_dsp/vpx_dsp_common.h"
+#include "vpx_dsp/vpx_filter.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+unsigned int vpx_avg_4x4_c(const uint8_t*, int p);
+#define vpx_avg_4x4 vpx_avg_4x4_c
+
+unsigned int vpx_avg_8x8_c(const uint8_t*, int p);
+#define vpx_avg_8x8 vpx_avg_8x8_c
+
+void vpx_comp_avg_pred_c(uint8_t* comp_pred,
+                         const uint8_t* pred,
+                         int width,
+                         int height,
+                         const uint8_t* ref,
+                         int ref_stride);
+void vpx_comp_avg_pred_vsx(uint8_t* comp_pred,
+                           const uint8_t* pred,
+                           int width,
+                           int height,
+                           const uint8_t* ref,
+                           int ref_stride);
+#define vpx_comp_avg_pred vpx_comp_avg_pred_vsx
+
+void vpx_convolve8_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+void vpx_convolve8_vsx(const uint8_t* src,
+                       ptrdiff_t src_stride,
+                       uint8_t* dst,
+                       ptrdiff_t dst_stride,
+                       const InterpKernel* filter,
+                       int x0_q4,
+                       int x_step_q4,
+                       int y0_q4,
+                       int y_step_q4,
+                       int w,
+                       int h);
+#define vpx_convolve8 vpx_convolve8_vsx
+
+void vpx_convolve8_avg_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+void vpx_convolve8_avg_vsx(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_convolve8_avg vpx_convolve8_avg_vsx
+
+void vpx_convolve8_avg_horiz_c(const uint8_t* src,
+                               ptrdiff_t src_stride,
+                               uint8_t* dst,
+                               ptrdiff_t dst_stride,
+                               const InterpKernel* filter,
+                               int x0_q4,
+                               int x_step_q4,
+                               int y0_q4,
+                               int y_step_q4,
+                               int w,
+                               int h);
+void vpx_convolve8_avg_horiz_vsx(const uint8_t* src,
+                                 ptrdiff_t src_stride,
+                                 uint8_t* dst,
+                                 ptrdiff_t dst_stride,
+                                 const InterpKernel* filter,
+                                 int x0_q4,
+                                 int x_step_q4,
+                                 int y0_q4,
+                                 int y_step_q4,
+                                 int w,
+                                 int h);
+#define vpx_convolve8_avg_horiz vpx_convolve8_avg_horiz_vsx
+
+void vpx_convolve8_avg_vert_c(const uint8_t* src,
+                              ptrdiff_t src_stride,
+                              uint8_t* dst,
+                              ptrdiff_t dst_stride,
+                              const InterpKernel* filter,
+                              int x0_q4,
+                              int x_step_q4,
+                              int y0_q4,
+                              int y_step_q4,
+                              int w,
+                              int h);
+void vpx_convolve8_avg_vert_vsx(const uint8_t* src,
+                                ptrdiff_t src_stride,
+                                uint8_t* dst,
+                                ptrdiff_t dst_stride,
+                                const InterpKernel* filter,
+                                int x0_q4,
+                                int x_step_q4,
+                                int y0_q4,
+                                int y_step_q4,
+                                int w,
+                                int h);
+#define vpx_convolve8_avg_vert vpx_convolve8_avg_vert_vsx
+
+void vpx_convolve8_horiz_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+void vpx_convolve8_horiz_vsx(const uint8_t* src,
+                             ptrdiff_t src_stride,
+                             uint8_t* dst,
+                             ptrdiff_t dst_stride,
+                             const InterpKernel* filter,
+                             int x0_q4,
+                             int x_step_q4,
+                             int y0_q4,
+                             int y_step_q4,
+                             int w,
+                             int h);
+#define vpx_convolve8_horiz vpx_convolve8_horiz_vsx
+
+void vpx_convolve8_vert_c(const uint8_t* src,
+                          ptrdiff_t src_stride,
+                          uint8_t* dst,
+                          ptrdiff_t dst_stride,
+                          const InterpKernel* filter,
+                          int x0_q4,
+                          int x_step_q4,
+                          int y0_q4,
+                          int y_step_q4,
+                          int w,
+                          int h);
+void vpx_convolve8_vert_vsx(const uint8_t* src,
+                            ptrdiff_t src_stride,
+                            uint8_t* dst,
+                            ptrdiff_t dst_stride,
+                            const InterpKernel* filter,
+                            int x0_q4,
+                            int x_step_q4,
+                            int y0_q4,
+                            int y_step_q4,
+                            int w,
+                            int h);
+#define vpx_convolve8_vert vpx_convolve8_vert_vsx
+
+void vpx_convolve_avg_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+void vpx_convolve_avg_vsx(const uint8_t* src,
+                          ptrdiff_t src_stride,
+                          uint8_t* dst,
+                          ptrdiff_t dst_stride,
+                          const InterpKernel* filter,
+                          int x0_q4,
+                          int x_step_q4,
+                          int y0_q4,
+                          int y_step_q4,
+                          int w,
+                          int h);
+#define vpx_convolve_avg vpx_convolve_avg_vsx
+
+void vpx_convolve_copy_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+void vpx_convolve_copy_vsx(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_convolve_copy vpx_convolve_copy_vsx
+
+void vpx_d117_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_16x16 vpx_d117_predictor_16x16_c
+
+void vpx_d117_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d117_predictor_32x32 vpx_d117_predictor_32x32_c
+
+void vpx_d117_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_4x4 vpx_d117_predictor_4x4_c
+
+void vpx_d117_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d117_predictor_8x8 vpx_d117_predictor_8x8_c
+
+void vpx_d135_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_16x16 vpx_d135_predictor_16x16_c
+
+void vpx_d135_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d135_predictor_32x32 vpx_d135_predictor_32x32_c
+
+void vpx_d135_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_4x4 vpx_d135_predictor_4x4_c
+
+void vpx_d135_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d135_predictor_8x8 vpx_d135_predictor_8x8_c
+
+void vpx_d153_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_16x16 vpx_d153_predictor_16x16_c
+
+void vpx_d153_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d153_predictor_32x32 vpx_d153_predictor_32x32_c
+
+void vpx_d153_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_4x4 vpx_d153_predictor_4x4_c
+
+void vpx_d153_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d153_predictor_8x8 vpx_d153_predictor_8x8_c
+
+void vpx_d207_predictor_16x16_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_16x16 vpx_d207_predictor_16x16_c
+
+void vpx_d207_predictor_32x32_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_d207_predictor_32x32 vpx_d207_predictor_32x32_c
+
+void vpx_d207_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_4x4 vpx_d207_predictor_4x4_c
+
+void vpx_d207_predictor_8x8_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d207_predictor_8x8 vpx_d207_predictor_8x8_c
+
+void vpx_d45_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+void vpx_d45_predictor_16x16_vsx(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_d45_predictor_16x16 vpx_d45_predictor_16x16_vsx
+
+void vpx_d45_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+void vpx_d45_predictor_32x32_vsx(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_d45_predictor_32x32 vpx_d45_predictor_32x32_vsx
+
+void vpx_d45_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d45_predictor_4x4 vpx_d45_predictor_4x4_c
+
+void vpx_d45_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+void vpx_d45_predictor_8x8_vsx(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d45_predictor_8x8 vpx_d45_predictor_8x8_vsx
+
+void vpx_d45e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d45e_predictor_4x4 vpx_d45e_predictor_4x4_c
+
+void vpx_d63_predictor_16x16_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+void vpx_d63_predictor_16x16_vsx(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_d63_predictor_16x16 vpx_d63_predictor_16x16_vsx
+
+void vpx_d63_predictor_32x32_c(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+void vpx_d63_predictor_32x32_vsx(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_d63_predictor_32x32 vpx_d63_predictor_32x32_vsx
+
+void vpx_d63_predictor_4x4_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_d63_predictor_4x4 vpx_d63_predictor_4x4_c
+
+void vpx_d63_predictor_8x8_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+void vpx_d63_predictor_8x8_vsx(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_d63_predictor_8x8 vpx_d63_predictor_8x8_vsx
+
+void vpx_d63e_predictor_4x4_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_d63e_predictor_4x4 vpx_d63e_predictor_4x4_c
+
+void vpx_dc_128_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+void vpx_dc_128_predictor_16x16_vsx(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define vpx_dc_128_predictor_16x16 vpx_dc_128_predictor_16x16_vsx
+
+void vpx_dc_128_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+void vpx_dc_128_predictor_32x32_vsx(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define vpx_dc_128_predictor_32x32 vpx_dc_128_predictor_32x32_vsx
+
+void vpx_dc_128_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_4x4 vpx_dc_128_predictor_4x4_c
+
+void vpx_dc_128_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_128_predictor_8x8 vpx_dc_128_predictor_8x8_c
+
+void vpx_dc_left_predictor_16x16_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+void vpx_dc_left_predictor_16x16_vsx(uint8_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint8_t* above,
+                                     const uint8_t* left);
+#define vpx_dc_left_predictor_16x16 vpx_dc_left_predictor_16x16_vsx
+
+void vpx_dc_left_predictor_32x32_c(uint8_t* dst,
+                                   ptrdiff_t y_stride,
+                                   const uint8_t* above,
+                                   const uint8_t* left);
+void vpx_dc_left_predictor_32x32_vsx(uint8_t* dst,
+                                     ptrdiff_t y_stride,
+                                     const uint8_t* above,
+                                     const uint8_t* left);
+#define vpx_dc_left_predictor_32x32 vpx_dc_left_predictor_32x32_vsx
+
+void vpx_dc_left_predictor_4x4_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_4x4 vpx_dc_left_predictor_4x4_c
+
+void vpx_dc_left_predictor_8x8_c(uint8_t* dst,
+                                 ptrdiff_t y_stride,
+                                 const uint8_t* above,
+                                 const uint8_t* left);
+#define vpx_dc_left_predictor_8x8 vpx_dc_left_predictor_8x8_c
+
+void vpx_dc_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+void vpx_dc_predictor_16x16_vsx(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_predictor_16x16 vpx_dc_predictor_16x16_vsx
+
+void vpx_dc_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+void vpx_dc_predictor_32x32_vsx(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_predictor_32x32 vpx_dc_predictor_32x32_vsx
+
+void vpx_dc_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_dc_predictor_4x4 vpx_dc_predictor_4x4_c
+
+void vpx_dc_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+void vpx_dc_predictor_8x8_vsx(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_dc_predictor_8x8 vpx_dc_predictor_8x8_vsx
+
+void vpx_dc_top_predictor_16x16_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+void vpx_dc_top_predictor_16x16_vsx(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define vpx_dc_top_predictor_16x16 vpx_dc_top_predictor_16x16_vsx
+
+void vpx_dc_top_predictor_32x32_c(uint8_t* dst,
+                                  ptrdiff_t y_stride,
+                                  const uint8_t* above,
+                                  const uint8_t* left);
+void vpx_dc_top_predictor_32x32_vsx(uint8_t* dst,
+                                    ptrdiff_t y_stride,
+                                    const uint8_t* above,
+                                    const uint8_t* left);
+#define vpx_dc_top_predictor_32x32 vpx_dc_top_predictor_32x32_vsx
+
+void vpx_dc_top_predictor_4x4_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_4x4 vpx_dc_top_predictor_4x4_c
+
+void vpx_dc_top_predictor_8x8_c(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_dc_top_predictor_8x8 vpx_dc_top_predictor_8x8_c
+
+void vpx_fdct16x16_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16 vpx_fdct16x16_c
+
+void vpx_fdct16x16_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct16x16_1 vpx_fdct16x16_1_c
+
+void vpx_fdct32x32_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32 vpx_fdct32x32_c
+
+void vpx_fdct32x32_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_1 vpx_fdct32x32_1_c
+
+void vpx_fdct32x32_rd_c(const int16_t* input, tran_low_t* output, int stride);
+void vpx_fdct32x32_rd_vsx(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct32x32_rd vpx_fdct32x32_rd_vsx
+
+void vpx_fdct4x4_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4 vpx_fdct4x4_c
+
+void vpx_fdct4x4_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct4x4_1 vpx_fdct4x4_1_c
+
+void vpx_fdct8x8_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8 vpx_fdct8x8_c
+
+void vpx_fdct8x8_1_c(const int16_t* input, tran_low_t* output, int stride);
+#define vpx_fdct8x8_1 vpx_fdct8x8_1_c
+
+void vpx_get16x16var_c(const uint8_t* src_ptr,
+                       int source_stride,
+                       const uint8_t* ref_ptr,
+                       int ref_stride,
+                       unsigned int* sse,
+                       int* sum);
+void vpx_get16x16var_vsx(const uint8_t* src_ptr,
+                         int source_stride,
+                         const uint8_t* ref_ptr,
+                         int ref_stride,
+                         unsigned int* sse,
+                         int* sum);
+#define vpx_get16x16var vpx_get16x16var_vsx
+
+unsigned int vpx_get4x4sse_cs_c(const unsigned char* src_ptr,
+                                int source_stride,
+                                const unsigned char* ref_ptr,
+                                int ref_stride);
+unsigned int vpx_get4x4sse_cs_vsx(const unsigned char* src_ptr,
+                                  int source_stride,
+                                  const unsigned char* ref_ptr,
+                                  int ref_stride);
+#define vpx_get4x4sse_cs vpx_get4x4sse_cs_vsx
+
+void vpx_get8x8var_c(const uint8_t* src_ptr,
+                     int source_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     unsigned int* sse,
+                     int* sum);
+void vpx_get8x8var_vsx(const uint8_t* src_ptr,
+                       int source_stride,
+                       const uint8_t* ref_ptr,
+                       int ref_stride,
+                       unsigned int* sse,
+                       int* sum);
+#define vpx_get8x8var vpx_get8x8var_vsx
+
+unsigned int vpx_get_mb_ss_c(const int16_t*);
+unsigned int vpx_get_mb_ss_vsx(const int16_t*);
+#define vpx_get_mb_ss vpx_get_mb_ss_vsx
+
+void vpx_h_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+void vpx_h_predictor_16x16_vsx(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_h_predictor_16x16 vpx_h_predictor_16x16_vsx
+
+void vpx_h_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+void vpx_h_predictor_32x32_vsx(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_h_predictor_32x32 vpx_h_predictor_32x32_vsx
+
+void vpx_h_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+void vpx_h_predictor_4x4_vsx(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_4x4 vpx_h_predictor_4x4_vsx
+
+void vpx_h_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+void vpx_h_predictor_8x8_vsx(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+#define vpx_h_predictor_8x8 vpx_h_predictor_8x8_vsx
+
+void vpx_hadamard_16x16_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+void vpx_hadamard_16x16_vsx(const int16_t* src_diff,
+                            ptrdiff_t src_stride,
+                            int16_t* coeff);
+#define vpx_hadamard_16x16 vpx_hadamard_16x16_vsx
+
+void vpx_hadamard_32x32_c(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+#define vpx_hadamard_32x32 vpx_hadamard_32x32_c
+
+void vpx_hadamard_8x8_c(const int16_t* src_diff,
+                        ptrdiff_t src_stride,
+                        int16_t* coeff);
+void vpx_hadamard_8x8_vsx(const int16_t* src_diff,
+                          ptrdiff_t src_stride,
+                          int16_t* coeff);
+#define vpx_hadamard_8x8 vpx_hadamard_8x8_vsx
+
+void vpx_he_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_he_predictor_4x4 vpx_he_predictor_4x4_c
+
+void vpx_idct16x16_10_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_10_add vpx_idct16x16_10_add_c
+
+void vpx_idct16x16_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_1_add vpx_idct16x16_1_add_c
+
+void vpx_idct16x16_256_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+void vpx_idct16x16_256_add_vsx(const tran_low_t* input,
+                               uint8_t* dest,
+                               int stride);
+#define vpx_idct16x16_256_add vpx_idct16x16_256_add_vsx
+
+void vpx_idct16x16_38_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct16x16_38_add vpx_idct16x16_38_add_c
+
+void vpx_idct32x32_1024_add_c(const tran_low_t* input,
+                              uint8_t* dest,
+                              int stride);
+void vpx_idct32x32_1024_add_vsx(const tran_low_t* input,
+                                uint8_t* dest,
+                                int stride);
+#define vpx_idct32x32_1024_add vpx_idct32x32_1024_add_vsx
+
+void vpx_idct32x32_135_add_c(const tran_low_t* input,
+                             uint8_t* dest,
+                             int stride);
+#define vpx_idct32x32_135_add vpx_idct32x32_135_add_c
+
+void vpx_idct32x32_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_1_add vpx_idct32x32_1_add_c
+
+void vpx_idct32x32_34_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct32x32_34_add vpx_idct32x32_34_add_c
+
+void vpx_idct4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+void vpx_idct4x4_16_add_vsx(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_16_add vpx_idct4x4_16_add_vsx
+
+void vpx_idct4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct4x4_1_add vpx_idct4x4_1_add_c
+
+void vpx_idct8x8_12_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_12_add vpx_idct8x8_12_add_c
+
+void vpx_idct8x8_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_1_add vpx_idct8x8_1_add_c
+
+void vpx_idct8x8_64_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+void vpx_idct8x8_64_add_vsx(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_idct8x8_64_add vpx_idct8x8_64_add_vsx
+
+int16_t vpx_int_pro_col_c(const uint8_t* ref, const int width);
+#define vpx_int_pro_col vpx_int_pro_col_c
+
+void vpx_int_pro_row_c(int16_t* hbuf,
+                       const uint8_t* ref,
+                       const int ref_stride,
+                       const int height);
+#define vpx_int_pro_row vpx_int_pro_row_c
+
+void vpx_iwht4x4_16_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+void vpx_iwht4x4_16_add_vsx(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_16_add vpx_iwht4x4_16_add_vsx
+
+void vpx_iwht4x4_1_add_c(const tran_low_t* input, uint8_t* dest, int stride);
+#define vpx_iwht4x4_1_add vpx_iwht4x4_1_add_c
+
+void vpx_lpf_horizontal_16_c(uint8_t* s,
+                             int pitch,
+                             const uint8_t* blimit,
+                             const uint8_t* limit,
+                             const uint8_t* thresh);
+#define vpx_lpf_horizontal_16 vpx_lpf_horizontal_16_c
+
+void vpx_lpf_horizontal_16_dual_c(uint8_t* s,
+                                  int pitch,
+                                  const uint8_t* blimit,
+                                  const uint8_t* limit,
+                                  const uint8_t* thresh);
+#define vpx_lpf_horizontal_16_dual vpx_lpf_horizontal_16_dual_c
+
+void vpx_lpf_horizontal_4_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_4 vpx_lpf_horizontal_4_c
+
+void vpx_lpf_horizontal_4_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_4_dual vpx_lpf_horizontal_4_dual_c
+
+void vpx_lpf_horizontal_8_c(uint8_t* s,
+                            int pitch,
+                            const uint8_t* blimit,
+                            const uint8_t* limit,
+                            const uint8_t* thresh);
+#define vpx_lpf_horizontal_8 vpx_lpf_horizontal_8_c
+
+void vpx_lpf_horizontal_8_dual_c(uint8_t* s,
+                                 int pitch,
+                                 const uint8_t* blimit0,
+                                 const uint8_t* limit0,
+                                 const uint8_t* thresh0,
+                                 const uint8_t* blimit1,
+                                 const uint8_t* limit1,
+                                 const uint8_t* thresh1);
+#define vpx_lpf_horizontal_8_dual vpx_lpf_horizontal_8_dual_c
+
+void vpx_lpf_vertical_16_c(uint8_t* s,
+                           int pitch,
+                           const uint8_t* blimit,
+                           const uint8_t* limit,
+                           const uint8_t* thresh);
+#define vpx_lpf_vertical_16 vpx_lpf_vertical_16_c
+
+void vpx_lpf_vertical_16_dual_c(uint8_t* s,
+                                int pitch,
+                                const uint8_t* blimit,
+                                const uint8_t* limit,
+                                const uint8_t* thresh);
+#define vpx_lpf_vertical_16_dual vpx_lpf_vertical_16_dual_c
+
+void vpx_lpf_vertical_4_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_4 vpx_lpf_vertical_4_c
+
+void vpx_lpf_vertical_4_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_4_dual vpx_lpf_vertical_4_dual_c
+
+void vpx_lpf_vertical_8_c(uint8_t* s,
+                          int pitch,
+                          const uint8_t* blimit,
+                          const uint8_t* limit,
+                          const uint8_t* thresh);
+#define vpx_lpf_vertical_8 vpx_lpf_vertical_8_c
+
+void vpx_lpf_vertical_8_dual_c(uint8_t* s,
+                               int pitch,
+                               const uint8_t* blimit0,
+                               const uint8_t* limit0,
+                               const uint8_t* thresh0,
+                               const uint8_t* blimit1,
+                               const uint8_t* limit1,
+                               const uint8_t* thresh1);
+#define vpx_lpf_vertical_8_dual vpx_lpf_vertical_8_dual_c
+
+void vpx_mbpost_proc_across_ip_c(unsigned char* dst,
+                                 int pitch,
+                                 int rows,
+                                 int cols,
+                                 int flimit);
+void vpx_mbpost_proc_across_ip_vsx(unsigned char* dst,
+                                   int pitch,
+                                   int rows,
+                                   int cols,
+                                   int flimit);
+#define vpx_mbpost_proc_across_ip vpx_mbpost_proc_across_ip_vsx
+
+void vpx_mbpost_proc_down_c(unsigned char* dst,
+                            int pitch,
+                            int rows,
+                            int cols,
+                            int flimit);
+void vpx_mbpost_proc_down_vsx(unsigned char* dst,
+                              int pitch,
+                              int rows,
+                              int cols,
+                              int flimit);
+#define vpx_mbpost_proc_down vpx_mbpost_proc_down_vsx
+
+void vpx_minmax_8x8_c(const uint8_t* s,
+                      int p,
+                      const uint8_t* d,
+                      int dp,
+                      int* min,
+                      int* max);
+#define vpx_minmax_8x8 vpx_minmax_8x8_c
+
+unsigned int vpx_mse16x16_c(const uint8_t* src_ptr,
+                            int source_stride,
+                            const uint8_t* ref_ptr,
+                            int recon_stride,
+                            unsigned int* sse);
+unsigned int vpx_mse16x16_vsx(const uint8_t* src_ptr,
+                              int source_stride,
+                              const uint8_t* ref_ptr,
+                              int recon_stride,
+                              unsigned int* sse);
+#define vpx_mse16x16 vpx_mse16x16_vsx
+
+unsigned int vpx_mse16x8_c(const uint8_t* src_ptr,
+                           int source_stride,
+                           const uint8_t* ref_ptr,
+                           int recon_stride,
+                           unsigned int* sse);
+unsigned int vpx_mse16x8_vsx(const uint8_t* src_ptr,
+                             int source_stride,
+                             const uint8_t* ref_ptr,
+                             int recon_stride,
+                             unsigned int* sse);
+#define vpx_mse16x8 vpx_mse16x8_vsx
+
+unsigned int vpx_mse8x16_c(const uint8_t* src_ptr,
+                           int source_stride,
+                           const uint8_t* ref_ptr,
+                           int recon_stride,
+                           unsigned int* sse);
+unsigned int vpx_mse8x16_vsx(const uint8_t* src_ptr,
+                             int source_stride,
+                             const uint8_t* ref_ptr,
+                             int recon_stride,
+                             unsigned int* sse);
+#define vpx_mse8x16 vpx_mse8x16_vsx
+
+unsigned int vpx_mse8x8_c(const uint8_t* src_ptr,
+                          int source_stride,
+                          const uint8_t* ref_ptr,
+                          int recon_stride,
+                          unsigned int* sse);
+unsigned int vpx_mse8x8_vsx(const uint8_t* src_ptr,
+                            int source_stride,
+                            const uint8_t* ref_ptr,
+                            int recon_stride,
+                            unsigned int* sse);
+#define vpx_mse8x8 vpx_mse8x8_vsx
+
+void vpx_plane_add_noise_c(uint8_t* start,
+                           const int8_t* noise,
+                           int blackclamp,
+                           int whiteclamp,
+                           int width,
+                           int height,
+                           int pitch);
+#define vpx_plane_add_noise vpx_plane_add_noise_c
+
+void vpx_post_proc_down_and_across_mb_row_c(unsigned char* src,
+                                            unsigned char* dst,
+                                            int src_pitch,
+                                            int dst_pitch,
+                                            int cols,
+                                            unsigned char* flimits,
+                                            int size);
+void vpx_post_proc_down_and_across_mb_row_vsx(unsigned char* src,
+                                              unsigned char* dst,
+                                              int src_pitch,
+                                              int dst_pitch,
+                                              int cols,
+                                              unsigned char* flimits,
+                                              int size);
+#define vpx_post_proc_down_and_across_mb_row \
+  vpx_post_proc_down_and_across_mb_row_vsx
+
+void vpx_quantize_b_c(const tran_low_t* coeff_ptr,
+                      intptr_t n_coeffs,
+                      int skip_block,
+                      const int16_t* zbin_ptr,
+                      const int16_t* round_ptr,
+                      const int16_t* quant_ptr,
+                      const int16_t* quant_shift_ptr,
+                      tran_low_t* qcoeff_ptr,
+                      tran_low_t* dqcoeff_ptr,
+                      const int16_t* dequant_ptr,
+                      uint16_t* eob_ptr,
+                      const int16_t* scan,
+                      const int16_t* iscan);
+void vpx_quantize_b_vsx(const tran_low_t* coeff_ptr,
+                        intptr_t n_coeffs,
+                        int skip_block,
+                        const int16_t* zbin_ptr,
+                        const int16_t* round_ptr,
+                        const int16_t* quant_ptr,
+                        const int16_t* quant_shift_ptr,
+                        tran_low_t* qcoeff_ptr,
+                        tran_low_t* dqcoeff_ptr,
+                        const int16_t* dequant_ptr,
+                        uint16_t* eob_ptr,
+                        const int16_t* scan,
+                        const int16_t* iscan);
+#define vpx_quantize_b vpx_quantize_b_vsx
+
+void vpx_quantize_b_32x32_c(const tran_low_t* coeff_ptr,
+                            intptr_t n_coeffs,
+                            int skip_block,
+                            const int16_t* zbin_ptr,
+                            const int16_t* round_ptr,
+                            const int16_t* quant_ptr,
+                            const int16_t* quant_shift_ptr,
+                            tran_low_t* qcoeff_ptr,
+                            tran_low_t* dqcoeff_ptr,
+                            const int16_t* dequant_ptr,
+                            uint16_t* eob_ptr,
+                            const int16_t* scan,
+                            const int16_t* iscan);
+void vpx_quantize_b_32x32_vsx(const tran_low_t* coeff_ptr,
+                              intptr_t n_coeffs,
+                              int skip_block,
+                              const int16_t* zbin_ptr,
+                              const int16_t* round_ptr,
+                              const int16_t* quant_ptr,
+                              const int16_t* quant_shift_ptr,
+                              tran_low_t* qcoeff_ptr,
+                              tran_low_t* dqcoeff_ptr,
+                              const int16_t* dequant_ptr,
+                              uint16_t* eob_ptr,
+                              const int16_t* scan,
+                              const int16_t* iscan);
+#define vpx_quantize_b_32x32 vpx_quantize_b_32x32_vsx
+
+unsigned int vpx_sad16x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad16x16_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad16x16 vpx_sad16x16_vsx
+
+unsigned int vpx_sad16x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad16x16_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad16x16_avg vpx_sad16x16_avg_vsx
+
+void vpx_sad16x16x3_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x3 vpx_sad16x16x3_c
+
+void vpx_sad16x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad16x16x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad16x16x4d vpx_sad16x16x4d_vsx
+
+void vpx_sad16x16x8_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* ref_ptr,
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad16x16x8 vpx_sad16x16x8_c
+
+unsigned int vpx_sad16x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad16x32_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad16x32 vpx_sad16x32_vsx
+
+unsigned int vpx_sad16x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad16x32_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad16x32_avg vpx_sad16x32_avg_vsx
+
+void vpx_sad16x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad16x32x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad16x32x4d vpx_sad16x32x4d_vsx
+
+unsigned int vpx_sad16x8_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+unsigned int vpx_sad16x8_vsx(const uint8_t* src_ptr,
+                             int src_stride,
+                             const uint8_t* ref_ptr,
+                             int ref_stride);
+#define vpx_sad16x8 vpx_sad16x8_vsx
+
+unsigned int vpx_sad16x8_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+unsigned int vpx_sad16x8_avg_vsx(const uint8_t* src_ptr,
+                                 int src_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 const uint8_t* second_pred);
+#define vpx_sad16x8_avg vpx_sad16x8_avg_vsx
+
+void vpx_sad16x8x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x3 vpx_sad16x8x3_c
+
+void vpx_sad16x8x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_ptr[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+void vpx_sad16x8x4d_vsx(const uint8_t* src_ptr,
+                        int src_stride,
+                        const uint8_t* const ref_ptr[],
+                        int ref_stride,
+                        uint32_t* sad_array);
+#define vpx_sad16x8x4d vpx_sad16x8x4d_vsx
+
+void vpx_sad16x8x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad16x8x8 vpx_sad16x8x8_c
+
+unsigned int vpx_sad32x16_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad32x16_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad32x16 vpx_sad32x16_vsx
+
+unsigned int vpx_sad32x16_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad32x16_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad32x16_avg vpx_sad32x16_avg_vsx
+
+void vpx_sad32x16x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad32x16x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad32x16x4d vpx_sad32x16x4d_vsx
+
+unsigned int vpx_sad32x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad32x32_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad32x32 vpx_sad32x32_vsx
+
+unsigned int vpx_sad32x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad32x32_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad32x32_avg vpx_sad32x32_avg_vsx
+
+void vpx_sad32x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad32x32x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad32x32x4d vpx_sad32x32x4d_vsx
+
+unsigned int vpx_sad32x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad32x64_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad32x64 vpx_sad32x64_vsx
+
+unsigned int vpx_sad32x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad32x64_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad32x64_avg vpx_sad32x64_avg_vsx
+
+void vpx_sad32x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad32x64x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad32x64x4d vpx_sad32x64x4d_vsx
+
+unsigned int vpx_sad4x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x4 vpx_sad4x4_c
+
+unsigned int vpx_sad4x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x4_avg vpx_sad4x4_avg_c
+
+void vpx_sad4x4x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x3 vpx_sad4x4x3_c
+
+void vpx_sad4x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_ptr[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x4x4d vpx_sad4x4x4d_c
+
+void vpx_sad4x4x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad4x4x8 vpx_sad4x4x8_c
+
+unsigned int vpx_sad4x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+#define vpx_sad4x8 vpx_sad4x8_c
+
+unsigned int vpx_sad4x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad4x8_avg vpx_sad4x8_avg_c
+
+void vpx_sad4x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_ptr[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad4x8x4d vpx_sad4x8x4d_c
+
+unsigned int vpx_sad64x32_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad64x32_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad64x32 vpx_sad64x32_vsx
+
+unsigned int vpx_sad64x32_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad64x32_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad64x32_avg vpx_sad64x32_avg_vsx
+
+void vpx_sad64x32x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad64x32x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad64x32x4d vpx_sad64x32x4d_vsx
+
+unsigned int vpx_sad64x64_c(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+unsigned int vpx_sad64x64_vsx(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride);
+#define vpx_sad64x64 vpx_sad64x64_vsx
+
+unsigned int vpx_sad64x64_avg_c(const uint8_t* src_ptr,
+                                int src_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                const uint8_t* second_pred);
+unsigned int vpx_sad64x64_avg_vsx(const uint8_t* src_ptr,
+                                  int src_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  const uint8_t* second_pred);
+#define vpx_sad64x64_avg vpx_sad64x64_avg_vsx
+
+void vpx_sad64x64x4d_c(const uint8_t* src_ptr,
+                       int src_stride,
+                       const uint8_t* const ref_ptr[],
+                       int ref_stride,
+                       uint32_t* sad_array);
+void vpx_sad64x64x4d_vsx(const uint8_t* src_ptr,
+                         int src_stride,
+                         const uint8_t* const ref_ptr[],
+                         int ref_stride,
+                         uint32_t* sad_array);
+#define vpx_sad64x64x4d vpx_sad64x64x4d_vsx
+
+unsigned int vpx_sad8x16_c(const uint8_t* src_ptr,
+                           int src_stride,
+                           const uint8_t* ref_ptr,
+                           int ref_stride);
+unsigned int vpx_sad8x16_vsx(const uint8_t* src_ptr,
+                             int src_stride,
+                             const uint8_t* ref_ptr,
+                             int ref_stride);
+#define vpx_sad8x16 vpx_sad8x16_vsx
+
+unsigned int vpx_sad8x16_avg_c(const uint8_t* src_ptr,
+                               int src_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               const uint8_t* second_pred);
+#define vpx_sad8x16_avg vpx_sad8x16_avg_c
+
+void vpx_sad8x16x3_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x3 vpx_sad8x16x3_c
+
+void vpx_sad8x16x4d_c(const uint8_t* src_ptr,
+                      int src_stride,
+                      const uint8_t* const ref_ptr[],
+                      int ref_stride,
+                      uint32_t* sad_array);
+#define vpx_sad8x16x4d vpx_sad8x16x4d_c
+
+void vpx_sad8x16x8_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* ref_ptr,
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x16x8 vpx_sad8x16x8_c
+
+unsigned int vpx_sad8x4_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+unsigned int vpx_sad8x4_vsx(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad8x4 vpx_sad8x4_vsx
+
+unsigned int vpx_sad8x4_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x4_avg vpx_sad8x4_avg_c
+
+void vpx_sad8x4x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_ptr[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x4x4d vpx_sad8x4x4d_c
+
+unsigned int vpx_sad8x8_c(const uint8_t* src_ptr,
+                          int src_stride,
+                          const uint8_t* ref_ptr,
+                          int ref_stride);
+unsigned int vpx_sad8x8_vsx(const uint8_t* src_ptr,
+                            int src_stride,
+                            const uint8_t* ref_ptr,
+                            int ref_stride);
+#define vpx_sad8x8 vpx_sad8x8_vsx
+
+unsigned int vpx_sad8x8_avg_c(const uint8_t* src_ptr,
+                              int src_stride,
+                              const uint8_t* ref_ptr,
+                              int ref_stride,
+                              const uint8_t* second_pred);
+#define vpx_sad8x8_avg vpx_sad8x8_avg_c
+
+void vpx_sad8x8x3_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x3 vpx_sad8x8x3_c
+
+void vpx_sad8x8x4d_c(const uint8_t* src_ptr,
+                     int src_stride,
+                     const uint8_t* const ref_ptr[],
+                     int ref_stride,
+                     uint32_t* sad_array);
+#define vpx_sad8x8x4d vpx_sad8x8x4d_c
+
+void vpx_sad8x8x8_c(const uint8_t* src_ptr,
+                    int src_stride,
+                    const uint8_t* ref_ptr,
+                    int ref_stride,
+                    uint32_t* sad_array);
+#define vpx_sad8x8x8 vpx_sad8x8x8_c
+
+int vpx_satd_c(const int16_t* coeff, int length);
+#define vpx_satd vpx_satd_c
+
+void vpx_scaled_2d_c(const uint8_t* src,
+                     ptrdiff_t src_stride,
+                     uint8_t* dst,
+                     ptrdiff_t dst_stride,
+                     const InterpKernel* filter,
+                     int x0_q4,
+                     int x_step_q4,
+                     int y0_q4,
+                     int y_step_q4,
+                     int w,
+                     int h);
+#define vpx_scaled_2d vpx_scaled_2d_c
+
+void vpx_scaled_avg_2d_c(const uint8_t* src,
+                         ptrdiff_t src_stride,
+                         uint8_t* dst,
+                         ptrdiff_t dst_stride,
+                         const InterpKernel* filter,
+                         int x0_q4,
+                         int x_step_q4,
+                         int y0_q4,
+                         int y_step_q4,
+                         int w,
+                         int h);
+#define vpx_scaled_avg_2d vpx_scaled_avg_2d_c
+
+void vpx_scaled_avg_horiz_c(const uint8_t* src,
+                            ptrdiff_t src_stride,
+                            uint8_t* dst,
+                            ptrdiff_t dst_stride,
+                            const InterpKernel* filter,
+                            int x0_q4,
+                            int x_step_q4,
+                            int y0_q4,
+                            int y_step_q4,
+                            int w,
+                            int h);
+#define vpx_scaled_avg_horiz vpx_scaled_avg_horiz_c
+
+void vpx_scaled_avg_vert_c(const uint8_t* src,
+                           ptrdiff_t src_stride,
+                           uint8_t* dst,
+                           ptrdiff_t dst_stride,
+                           const InterpKernel* filter,
+                           int x0_q4,
+                           int x_step_q4,
+                           int y0_q4,
+                           int y_step_q4,
+                           int w,
+                           int h);
+#define vpx_scaled_avg_vert vpx_scaled_avg_vert_c
+
+void vpx_scaled_horiz_c(const uint8_t* src,
+                        ptrdiff_t src_stride,
+                        uint8_t* dst,
+                        ptrdiff_t dst_stride,
+                        const InterpKernel* filter,
+                        int x0_q4,
+                        int x_step_q4,
+                        int y0_q4,
+                        int y_step_q4,
+                        int w,
+                        int h);
+#define vpx_scaled_horiz vpx_scaled_horiz_c
+
+void vpx_scaled_vert_c(const uint8_t* src,
+                       ptrdiff_t src_stride,
+                       uint8_t* dst,
+                       ptrdiff_t dst_stride,
+                       const InterpKernel* filter,
+                       int x0_q4,
+                       int x_step_q4,
+                       int y0_q4,
+                       int y_step_q4,
+                       int w,
+                       int h);
+#define vpx_scaled_vert vpx_scaled_vert_c
+
+uint32_t vpx_sub_pixel_avg_variance16x16_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x16 vpx_sub_pixel_avg_variance16x16_c
+
+uint32_t vpx_sub_pixel_avg_variance16x32_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x32 vpx_sub_pixel_avg_variance16x32_c
+
+uint32_t vpx_sub_pixel_avg_variance16x8_c(const uint8_t* src_ptr,
+                                          int source_stride,
+                                          int xoffset,
+                                          int yoffset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance16x8 vpx_sub_pixel_avg_variance16x8_c
+
+uint32_t vpx_sub_pixel_avg_variance32x16_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x16 vpx_sub_pixel_avg_variance32x16_c
+
+uint32_t vpx_sub_pixel_avg_variance32x32_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x32 vpx_sub_pixel_avg_variance32x32_c
+
+uint32_t vpx_sub_pixel_avg_variance32x64_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance32x64 vpx_sub_pixel_avg_variance32x64_c
+
+uint32_t vpx_sub_pixel_avg_variance4x4_c(const uint8_t* src_ptr,
+                                         int source_stride,
+                                         int xoffset,
+                                         int yoffset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x4 vpx_sub_pixel_avg_variance4x4_c
+
+uint32_t vpx_sub_pixel_avg_variance4x8_c(const uint8_t* src_ptr,
+                                         int source_stride,
+                                         int xoffset,
+                                         int yoffset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance4x8 vpx_sub_pixel_avg_variance4x8_c
+
+uint32_t vpx_sub_pixel_avg_variance64x32_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x32 vpx_sub_pixel_avg_variance64x32_c
+
+uint32_t vpx_sub_pixel_avg_variance64x64_c(const uint8_t* src_ptr,
+                                           int source_stride,
+                                           int xoffset,
+                                           int yoffset,
+                                           const uint8_t* ref_ptr,
+                                           int ref_stride,
+                                           uint32_t* sse,
+                                           const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance64x64 vpx_sub_pixel_avg_variance64x64_c
+
+uint32_t vpx_sub_pixel_avg_variance8x16_c(const uint8_t* src_ptr,
+                                          int source_stride,
+                                          int xoffset,
+                                          int yoffset,
+                                          const uint8_t* ref_ptr,
+                                          int ref_stride,
+                                          uint32_t* sse,
+                                          const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x16 vpx_sub_pixel_avg_variance8x16_c
+
+uint32_t vpx_sub_pixel_avg_variance8x4_c(const uint8_t* src_ptr,
+                                         int source_stride,
+                                         int xoffset,
+                                         int yoffset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x4 vpx_sub_pixel_avg_variance8x4_c
+
+uint32_t vpx_sub_pixel_avg_variance8x8_c(const uint8_t* src_ptr,
+                                         int source_stride,
+                                         int xoffset,
+                                         int yoffset,
+                                         const uint8_t* ref_ptr,
+                                         int ref_stride,
+                                         uint32_t* sse,
+                                         const uint8_t* second_pred);
+#define vpx_sub_pixel_avg_variance8x8 vpx_sub_pixel_avg_variance8x8_c
+
+uint32_t vpx_sub_pixel_variance16x16_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x16 vpx_sub_pixel_variance16x16_c
+
+uint32_t vpx_sub_pixel_variance16x32_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance16x32 vpx_sub_pixel_variance16x32_c
+
+uint32_t vpx_sub_pixel_variance16x8_c(const uint8_t* src_ptr,
+                                      int source_stride,
+                                      int xoffset,
+                                      int yoffset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance16x8 vpx_sub_pixel_variance16x8_c
+
+uint32_t vpx_sub_pixel_variance32x16_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x16 vpx_sub_pixel_variance32x16_c
+
+uint32_t vpx_sub_pixel_variance32x32_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x32 vpx_sub_pixel_variance32x32_c
+
+uint32_t vpx_sub_pixel_variance32x64_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance32x64 vpx_sub_pixel_variance32x64_c
+
+uint32_t vpx_sub_pixel_variance4x4_c(const uint8_t* src_ptr,
+                                     int source_stride,
+                                     int xoffset,
+                                     int yoffset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x4 vpx_sub_pixel_variance4x4_c
+
+uint32_t vpx_sub_pixel_variance4x8_c(const uint8_t* src_ptr,
+                                     int source_stride,
+                                     int xoffset,
+                                     int yoffset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance4x8 vpx_sub_pixel_variance4x8_c
+
+uint32_t vpx_sub_pixel_variance64x32_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x32 vpx_sub_pixel_variance64x32_c
+
+uint32_t vpx_sub_pixel_variance64x64_c(const uint8_t* src_ptr,
+                                       int source_stride,
+                                       int xoffset,
+                                       int yoffset,
+                                       const uint8_t* ref_ptr,
+                                       int ref_stride,
+                                       uint32_t* sse);
+#define vpx_sub_pixel_variance64x64 vpx_sub_pixel_variance64x64_c
+
+uint32_t vpx_sub_pixel_variance8x16_c(const uint8_t* src_ptr,
+                                      int source_stride,
+                                      int xoffset,
+                                      int yoffset,
+                                      const uint8_t* ref_ptr,
+                                      int ref_stride,
+                                      uint32_t* sse);
+#define vpx_sub_pixel_variance8x16 vpx_sub_pixel_variance8x16_c
+
+uint32_t vpx_sub_pixel_variance8x4_c(const uint8_t* src_ptr,
+                                     int source_stride,
+                                     int xoffset,
+                                     int yoffset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x4 vpx_sub_pixel_variance8x4_c
+
+uint32_t vpx_sub_pixel_variance8x8_c(const uint8_t* src_ptr,
+                                     int source_stride,
+                                     int xoffset,
+                                     int yoffset,
+                                     const uint8_t* ref_ptr,
+                                     int ref_stride,
+                                     uint32_t* sse);
+#define vpx_sub_pixel_variance8x8 vpx_sub_pixel_variance8x8_c
+
+void vpx_subtract_block_c(int rows,
+                          int cols,
+                          int16_t* diff_ptr,
+                          ptrdiff_t diff_stride,
+                          const uint8_t* src_ptr,
+                          ptrdiff_t src_stride,
+                          const uint8_t* pred_ptr,
+                          ptrdiff_t pred_stride);
+void vpx_subtract_block_vsx(int rows,
+                            int cols,
+                            int16_t* diff_ptr,
+                            ptrdiff_t diff_stride,
+                            const uint8_t* src_ptr,
+                            ptrdiff_t src_stride,
+                            const uint8_t* pred_ptr,
+                            ptrdiff_t pred_stride);
+#define vpx_subtract_block vpx_subtract_block_vsx
+
+uint64_t vpx_sum_squares_2d_i16_c(const int16_t* src, int stride, int size);
+#define vpx_sum_squares_2d_i16 vpx_sum_squares_2d_i16_c
+
+void vpx_tm_predictor_16x16_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+void vpx_tm_predictor_16x16_vsx(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_tm_predictor_16x16 vpx_tm_predictor_16x16_vsx
+
+void vpx_tm_predictor_32x32_c(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+void vpx_tm_predictor_32x32_vsx(uint8_t* dst,
+                                ptrdiff_t y_stride,
+                                const uint8_t* above,
+                                const uint8_t* left);
+#define vpx_tm_predictor_32x32 vpx_tm_predictor_32x32_vsx
+
+void vpx_tm_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+void vpx_tm_predictor_4x4_vsx(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_4x4 vpx_tm_predictor_4x4_vsx
+
+void vpx_tm_predictor_8x8_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+void vpx_tm_predictor_8x8_vsx(uint8_t* dst,
+                              ptrdiff_t y_stride,
+                              const uint8_t* above,
+                              const uint8_t* left);
+#define vpx_tm_predictor_8x8 vpx_tm_predictor_8x8_vsx
+
+void vpx_v_predictor_16x16_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+void vpx_v_predictor_16x16_vsx(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_v_predictor_16x16 vpx_v_predictor_16x16_vsx
+
+void vpx_v_predictor_32x32_c(uint8_t* dst,
+                             ptrdiff_t y_stride,
+                             const uint8_t* above,
+                             const uint8_t* left);
+void vpx_v_predictor_32x32_vsx(uint8_t* dst,
+                               ptrdiff_t y_stride,
+                               const uint8_t* above,
+                               const uint8_t* left);
+#define vpx_v_predictor_32x32 vpx_v_predictor_32x32_vsx
+
+void vpx_v_predictor_4x4_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_4x4 vpx_v_predictor_4x4_c
+
+void vpx_v_predictor_8x8_c(uint8_t* dst,
+                           ptrdiff_t y_stride,
+                           const uint8_t* above,
+                           const uint8_t* left);
+#define vpx_v_predictor_8x8 vpx_v_predictor_8x8_c
+
+unsigned int vpx_variance16x16_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance16x16_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance16x16 vpx_variance16x16_vsx
+
+unsigned int vpx_variance16x32_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance16x32_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance16x32 vpx_variance16x32_vsx
+
+unsigned int vpx_variance16x8_c(const uint8_t* src_ptr,
+                                int source_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+unsigned int vpx_variance16x8_vsx(const uint8_t* src_ptr,
+                                  int source_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  unsigned int* sse);
+#define vpx_variance16x8 vpx_variance16x8_vsx
+
+unsigned int vpx_variance32x16_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance32x16_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance32x16 vpx_variance32x16_vsx
+
+unsigned int vpx_variance32x32_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance32x32_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance32x32 vpx_variance32x32_vsx
+
+unsigned int vpx_variance32x64_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance32x64_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance32x64 vpx_variance32x64_vsx
+
+unsigned int vpx_variance4x4_c(const uint8_t* src_ptr,
+                               int source_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+unsigned int vpx_variance4x4_vsx(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance4x4 vpx_variance4x4_vsx
+
+unsigned int vpx_variance4x8_c(const uint8_t* src_ptr,
+                               int source_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+unsigned int vpx_variance4x8_vsx(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance4x8 vpx_variance4x8_vsx
+
+unsigned int vpx_variance64x32_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance64x32_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance64x32 vpx_variance64x32_vsx
+
+unsigned int vpx_variance64x64_c(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+unsigned int vpx_variance64x64_vsx(const uint8_t* src_ptr,
+                                   int source_stride,
+                                   const uint8_t* ref_ptr,
+                                   int ref_stride,
+                                   unsigned int* sse);
+#define vpx_variance64x64 vpx_variance64x64_vsx
+
+unsigned int vpx_variance8x16_c(const uint8_t* src_ptr,
+                                int source_stride,
+                                const uint8_t* ref_ptr,
+                                int ref_stride,
+                                unsigned int* sse);
+unsigned int vpx_variance8x16_vsx(const uint8_t* src_ptr,
+                                  int source_stride,
+                                  const uint8_t* ref_ptr,
+                                  int ref_stride,
+                                  unsigned int* sse);
+#define vpx_variance8x16 vpx_variance8x16_vsx
+
+unsigned int vpx_variance8x4_c(const uint8_t* src_ptr,
+                               int source_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+unsigned int vpx_variance8x4_vsx(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance8x4 vpx_variance8x4_vsx
+
+unsigned int vpx_variance8x8_c(const uint8_t* src_ptr,
+                               int source_stride,
+                               const uint8_t* ref_ptr,
+                               int ref_stride,
+                               unsigned int* sse);
+unsigned int vpx_variance8x8_vsx(const uint8_t* src_ptr,
+                                 int source_stride,
+                                 const uint8_t* ref_ptr,
+                                 int ref_stride,
+                                 unsigned int* sse);
+#define vpx_variance8x8 vpx_variance8x8_vsx
+
+void vpx_ve_predictor_4x4_c(uint8_t* dst,
+                            ptrdiff_t y_stride,
+                            const uint8_t* above,
+                            const uint8_t* left);
+#define vpx_ve_predictor_4x4 vpx_ve_predictor_4x4_c
+
+int vpx_vector_var_c(const int16_t* ref, const int16_t* src, const int bwl);
+#define vpx_vector_var vpx_vector_var_c
+
+void vpx_dsp_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h	1970-01-01 00:00:00.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/linux/ppc64/vpx_scale_rtcd.h	2020-04-08 22:55:45.189363098 +0000
@@ -0,0 +1,100 @@
+// This file is generated. Do not edit.
+#ifndef VPX_SCALE_RTCD_H_
+#define VPX_SCALE_RTCD_H_
+
+#ifdef RTCD_C
+#define RTCD_EXTERN
+#else
+#define RTCD_EXTERN extern
+#endif
+
+struct yv12_buffer_config;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void vp8_horizontal_line_2_1_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_2_1_scale vp8_horizontal_line_2_1_scale_c
+
+void vp8_horizontal_line_5_3_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_3_scale vp8_horizontal_line_5_3_scale_c
+
+void vp8_horizontal_line_5_4_scale_c(const unsigned char* source,
+                                     unsigned int source_width,
+                                     unsigned char* dest,
+                                     unsigned int dest_width);
+#define vp8_horizontal_line_5_4_scale vp8_horizontal_line_5_4_scale_c
+
+void vp8_vertical_band_2_1_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale vp8_vertical_band_2_1_scale_c
+
+void vp8_vertical_band_2_1_scale_i_c(unsigned char* source,
+                                     unsigned int src_pitch,
+                                     unsigned char* dest,
+                                     unsigned int dest_pitch,
+                                     unsigned int dest_width);
+#define vp8_vertical_band_2_1_scale_i vp8_vertical_band_2_1_scale_i_c
+
+void vp8_vertical_band_5_3_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_3_scale vp8_vertical_band_5_3_scale_c
+
+void vp8_vertical_band_5_4_scale_c(unsigned char* source,
+                                   unsigned int src_pitch,
+                                   unsigned char* dest,
+                                   unsigned int dest_pitch,
+                                   unsigned int dest_width);
+#define vp8_vertical_band_5_4_scale vp8_vertical_band_5_4_scale_c
+
+void vp8_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vp8_yv12_copy_frame vp8_yv12_copy_frame_c
+
+void vp8_yv12_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vp8_yv12_extend_frame_borders vp8_yv12_extend_frame_borders_c
+
+void vpx_extend_frame_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_borders vpx_extend_frame_borders_c
+
+void vpx_extend_frame_inner_borders_c(struct yv12_buffer_config* ybf);
+#define vpx_extend_frame_inner_borders vpx_extend_frame_inner_borders_c
+
+void vpx_yv12_copy_frame_c(const struct yv12_buffer_config* src_ybc,
+                           struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_frame vpx_yv12_copy_frame_c
+
+void vpx_yv12_copy_y_c(const struct yv12_buffer_config* src_ybc,
+                       struct yv12_buffer_config* dst_ybc);
+#define vpx_yv12_copy_y vpx_yv12_copy_y_c
+
+void vpx_scale_rtcd(void);
+
+#include "vpx_config.h"
+
+#ifdef RTCD_C
+#include "vpx_ports/ppc.h"
+static void setup_rtcd_internal(void) {
+  int flags = ppc_simd_caps();
+  (void)flags;
+}
+#endif
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/vpx_version.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/vpx_version.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/config/vpx_version.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/config/vpx_version.h	2020-04-08 22:55:59.587665202 +0000
@@ -2,7 +2,7 @@
 #define VERSION_MAJOR  1
 #define VERSION_MINOR  7
 #define VERSION_PATCH  0
-#define VERSION_EXTRA  "644-gb0dfe4e5c"
+#define VERSION_EXTRA  ""
 #define VERSION_PACKED ((VERSION_MAJOR<<16)|(VERSION_MINOR<<8)|(VERSION_PATCH))
-#define VERSION_STRING_NOSP "v1.7.0-644-gb0dfe4e5c"
-#define VERSION_STRING      " v1.7.0-644-gb0dfe4e5c"
+#define VERSION_STRING_NOSP "v1.7.0"
+#define VERSION_STRING      " v1.7.0"
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/libvpx/libs.mk qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/libvpx/libs.mk
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/libvpx/source/libvpx/libs.mk	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/libvpx/source/libvpx/libs.mk	2020-04-08 22:53:21.946259867 +0000
@@ -395,7 +395,7 @@
 ifeq ($(CONFIG_UNIT_TESTS),yes)
 LIBVPX_TEST_DATA_PATH ?= .
 
-include $(SRC_PATH_BARE)/test/test.mk
+# include $(SRC_PATH_BARE)/test/test.mk
 LIBVPX_TEST_SRCS=$(addprefix test/,$(call enabled,LIBVPX_TEST_SRCS))
 LIBVPX_TEST_BIN=./test_libvpx$(EXE_SFX)
 LIBVPX_TEST_DATA=$(addprefix $(LIBVPX_TEST_DATA_PATH)/,\
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/lss/linux_syscall_support.h	2020-04-08 22:45:29.162130498 +0000
@@ -3905,7 +3905,7 @@
       LSS_REG(2, buf);
       LSS_BODY(void*, mmap2, "0"(__r2));
     }
-#else
+#elif !defined(__powerpc64__) /* ppc64 doesn't have mmap2 */
     #define __NR__mmap2 __NR_mmap2
     LSS_INLINE _syscall6(void*, _mmap2,            void*, s,
                          size_t,                   l, int,               p,
@@ -4036,7 +4036,7 @@
   #if defined(__i386__) ||                                                    \
       defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
-      defined(__PPC__) ||                                                     \
+     (defined(__PPC__) && !defined(__powerpc64__)) ||                                                     \
      (defined(__s390__) && !defined(__s390x__))
     /* On these architectures, implement mmap() with mmap2(). */
     LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/page_allocator.h	2020-04-08 22:59:40.281649336 +0000
@@ -16,7 +16,7 @@
 namespace pdfium {
 namespace base {
 
-#if defined(OS_WIN)
+#if defined(OS_WIN) || defined(ARCH_CPU_PPC64)
 static const size_t kPageAllocationGranularityShift = 16;  // 64KB
 #elif defined(_MIPS_ARCH_LOONGSON)
 static const size_t kPageAllocationGranularityShift = 14;  // 16KB
@@ -35,6 +35,8 @@
 // Loongson have 16384 sized system pages.
 #if defined(_MIPS_ARCH_LOONGSON)
 static const size_t kSystemPageSize = 16384;
+#elif defined(ARCH_CPU_PPC64)
+static const size_t kSystemPageSize = 65536;
 #else
 static const size_t kSystemPageSize = 4096;
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/pdfium/third_party/base/allocator/partition_allocator/partition_alloc.h	2020-04-08 23:00:19.986970312 +0000
@@ -97,6 +97,8 @@
 // against the end of a system page.
 #if defined(_MIPS_ARCH_LOONGSON)
 static const size_t kPartitionPageShift = 16;  // 64KB
+#elif defined(ARCH_CPU_PPC64)
+static const size_t kPartitionPageShift = 18;  // 256KB
 #else
 static const size_t kPartitionPageShift = 14;  // 16KB
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/sqlite/amalgamation/sqlite3.c qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/sqlite/amalgamation/sqlite3.c
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/sqlite/amalgamation/sqlite3.c	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/sqlite/amalgamation/sqlite3.c	2020-04-08 23:03:50.662149254 +0000
@@ -14052,7 +14052,8 @@
 # if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \
      defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \
      defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \
-     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)
+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64) || \
+     (defined(__powerpc64__) && (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)     || defined(__ppc__) || \
        defined(__ARMEB__) || defined(__AARCH64EB__)
@@ -154481,31 +154482,31 @@
 };
 /* aKWCode[i] is the parser symbol code for the i-th keyword */
 static const unsigned char aKWCode[123] = {
-  TK_BEFORE,     TK_FOREIGN,    TK_FOR,        TK_IGNORE,     TK_REFERENCES, 
-  TK_ESCAPE,     TK_EACH,       TK_CHECK,      TK_KEY,        TK_ISNULL,     
-  TK_NULLS,      TK_SAVEPOINT,  TK_INTERSECT,  TK_TABLE,      TK_JOIN_KW,    
-  TK_THEN,       TK_END,        TK_DESC,       TK_CONSTRAINT, TK_INTO,       
-  TK_OFFSET,     TK_OF,         TK_SET,        TK_TRANSACTION,TK_ACTION,     
-  TK_ON,         TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       
-  TK_LIKE_KW,    TK_ELSE,       TK_SELECT,     TK_TRIGGER,    TK_RAISE,      
-  TK_EXCEPT,     TK_TEMP,       TK_TEMP,       TK_OR,         TK_WITHOUT,    
-  TK_WITH,       TK_JOIN_KW,    TK_RELEASE,    TK_EXCLUSIVE,  TK_EXISTS,     
-  TK_ATTACH,     TK_HAVING,     TK_GROUP,      TK_UPDATE,     TK_BEGIN,      
-  TK_INSTEAD,    TK_ADD,        TK_DATABASE,   TK_AS,         TK_BETWEEN,    
-  TK_JOIN_KW,    TK_ALTER,      TK_RECURSIVE,  TK_CASCADE,    TK_ASC,        
-  TK_DEFERRABLE, TK_CASE,       TK_COLLATE,    TK_CREATE,     TK_CTIME_KW,   
-  TK_DELETE,     TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       TK_INDEXED,    
-  TK_INDEX,      TK_DEFAULT,    TK_MATCH,      TK_PRAGMA,     TK_ABORT,      
-  TK_VALUES,     TK_VIRTUAL,    TK_LAST,       TK_WHEN,       TK_WHERE,      
-  TK_LIKE_KW,    TK_PRIMARY,    TK_AFTER,      TK_RENAME,     TK_AND,        
-  TK_DEFERRED,   TK_DISTINCT,   TK_IS,         TK_AUTOINCR,   TK_TO,         
-  TK_IN,         TK_CAST,       TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   
-  TK_JOIN_KW,    TK_CTIME_KW,   TK_CTIME_KW,   TK_DROP,       TK_FAIL,       
-  TK_LIMIT,      TK_FIRST,      TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,    
-  TK_BY,         TK_IF,         TK_JOIN_KW,    TK_REPLACE,    TK_INSERT,     
-  TK_ORDER,      TK_RESTRICT,   TK_JOIN_KW,    TK_ROLLBACK,   TK_ROWS,       
-  TK_ROW,        TK_UNION,      TK_UNIQUE,     TK_USING,      TK_VACUUM,     
-  TK_VIEW,       TK_INITIALLY,  TK_ALL,        
+  TK_BEFORE,     TK_FOREIGN,    TK_FOR,        TK_IGNORE,     TK_REFERENCES,
+  TK_ESCAPE,     TK_EACH,       TK_CHECK,      TK_KEY,        TK_ISNULL,
+  TK_NULLS,      TK_SAVEPOINT,  TK_INTERSECT,  TK_TABLE,      TK_JOIN_KW,
+  TK_THEN,       TK_END,        TK_DESC,       TK_CONSTRAINT, TK_INTO,
+  TK_OFFSET,     TK_OF,         TK_SET,        TK_TRANSACTION,TK_ACTION,
+  TK_ON,         TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,
+  TK_LIKE_KW,    TK_ELSE,       TK_SELECT,     TK_TRIGGER,    TK_RAISE,
+  TK_EXCEPT,     TK_TEMP,       TK_TEMP,       TK_OR,         TK_WITHOUT,
+  TK_WITH,       TK_JOIN_KW,    TK_RELEASE,    TK_EXCLUSIVE,  TK_EXISTS,
+  TK_ATTACH,     TK_HAVING,     TK_GROUP,      TK_UPDATE,     TK_BEGIN,
+  TK_INSTEAD,    TK_ADD,        TK_DATABASE,   TK_AS,         TK_BETWEEN,
+  TK_JOIN_KW,    TK_ALTER,      TK_RECURSIVE,  TK_CASCADE,    TK_ASC,
+  TK_DEFERRABLE, TK_CASE,       TK_COLLATE,    TK_CREATE,     TK_CTIME_KW,
+  TK_DELETE,     TK_DETACH,     TK_IMMEDIATE,  TK_JOIN,       TK_INDEXED,
+  TK_INDEX,      TK_DEFAULT,    TK_MATCH,      TK_PRAGMA,     TK_ABORT,
+  TK_VALUES,     TK_VIRTUAL,    TK_LAST,       TK_WHEN,       TK_WHERE,
+  TK_LIKE_KW,    TK_PRIMARY,    TK_AFTER,      TK_RENAME,     TK_AND,
+  TK_DEFERRED,   TK_DISTINCT,   TK_IS,         TK_AUTOINCR,   TK_TO,
+  TK_IN,         TK_CAST,       TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,
+  TK_JOIN_KW,    TK_CTIME_KW,   TK_CTIME_KW,   TK_DROP,       TK_FAIL,
+  TK_LIMIT,      TK_FIRST,      TK_FROM,       TK_JOIN_KW,    TK_LIKE_KW,
+  TK_BY,         TK_IF,         TK_JOIN_KW,    TK_REPLACE,    TK_INSERT,
+  TK_ORDER,      TK_RESTRICT,   TK_JOIN_KW,    TK_ROLLBACK,   TK_ROWS,
+  TK_ROW,        TK_UNION,      TK_UNIQUE,     TK_USING,      TK_VACUUM,
+  TK_VIEW,       TK_INITIALLY,  TK_ALL,
 };
 /* Check to see if z[0..n-1] is a keyword. If it is, write the
 ** parser symbol code for that keyword into *pType.  Always
@@ -204188,31 +204189,31 @@
 /********* Begin destructor definitions ***************************************/
     case 16: /* input */
 {
- (void)pParse; 
+ (void)pParse;
 }
       break;
     case 17: /* expr */
     case 18: /* cnearset */
     case 19: /* exprlist */
 {
- sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy24)); 
+ sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy24));
 }
       break;
     case 20: /* colset */
     case 21: /* colsetlist */
 {
- sqlite3_free((fts5yypminor->fts5yy11)); 
+ sqlite3_free((fts5yypminor->fts5yy11));
 }
       break;
     case 22: /* nearset */
     case 23: /* nearphrases */
 {
- sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46)); 
+ sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46));
 }
       break;
     case 24: /* phrase */
 {
- sqlite3Fts5ParsePhraseFree((fts5yypminor->fts5yy53)); 
+ sqlite3Fts5ParsePhraseFree((fts5yypminor->fts5yy53));
 }
       break;
 /********* End destructor definitions *****************************************/
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/sqlite/src/src/sqliteInt.h	2020-04-08 23:01:16.620297076 +0000
@@ -833,7 +833,8 @@
 # if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \
      defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \
      defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \
-     defined(__arm__)  || defined(_M_ARM64)
+     defined(__arm__)  || defined(_M_ARM64)   || defined(__powerpc64__) && \
+     (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
 #   define SQLITE_BYTEORDER    1234
 # elif defined(sparc)    || defined(__ppc__)
 #   define SQLITE_BYTEORDER    4321
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/webrtc/modules/desktop_capture/differ_block.cc	2020-04-08 22:29:45.883110017 +0000
@@ -30,11 +30,7 @@
   static bool (*diff_proc)(const uint8_t*, const uint8_t*) = nullptr;
 
   if (!diff_proc) {
-#if defined(WEBRTC_ARCH_ARM_FAMILY) || defined(WEBRTC_ARCH_MIPS_FAMILY)
-    // For ARM and MIPS processors, always use C version.
-    // TODO(hclam): Implement a NEON version.
-    diff_proc = &VectorDifference_C;
-#else
+#if defined(WEBRTC_ARCH_X86_FAMILY)
     bool have_sse2 = WebRtc_GetCPUInfo(kSSE2) != 0;
     // For x86 processors, check if SSE2 is supported.
     if (have_sse2 && kBlockSize == 32) {
@@ -44,6 +40,10 @@
     } else {
       diff_proc = &VectorDifference_C;
     }
+#else
+    // For other processors, always use C version.
+    // TODO(hclam): Implement a NEON version.
+    diff_proc = &VectorDifference_C;
 #endif
   }
 
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/third_party/webrtc/rtc_base/system/arch.h	2020-04-08 22:29:07.487624580 +0000
@@ -47,6 +47,18 @@
 #elif defined(__pnacl__)
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
+#elif defined(__PPC__)
+#define WEBRTC_ARCH_PPC_FAMILY
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define WEBRTC_ARCH_LITTLE_ENDIAN
+#else
+#define WEBRTC_ARCH_BIG_ENDIAN
+#endif
+#if defined(__LP64__)
+#define WEBRTC_ARCH_64_BITS
+#else
+#define WEBRTC_ARCH_32_BITS
+#endif
 #else
 #error Please add support for your architecture in typedefs.h
 #endif
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/v8/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/v8/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/v8/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/v8/BUILD.gn	2020-04-08 23:01:05.981550610 +0000
@@ -507,6 +507,12 @@
     }
     if (host_byteorder == "little") {
       defines += [ "V8_TARGET_ARCH_PPC_LE" ]
+        cflags += [
+        # Enable usage of AltiVec, VSX, and other POWER8 and higher features
+        "-mcpu=power8",
+        "-maltivec",
+        "-mvsx",
+      ]
     } else if (host_byteorder == "big") {
       defines += [ "V8_TARGET_ARCH_PPC_BE" ]
       if (current_os == "aix") {
diff -Naur qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/v8/test/BUILD.gn qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/v8/test/BUILD.gn
--- qtwebengine-everywhere-src-5.12.7.orig/src/3rdparty/chromium/v8/test/BUILD.gn	2020-01-24 17:54:43.000000000 +0000
+++ qtwebengine-everywhere-src-5.12.7/src/3rdparty/chromium/v8/test/BUILD.gn	2020-04-08 23:00:56.442674569 +0000
@@ -30,7 +30,7 @@
     deps += [
       "cctest:cctest",
       "cctest:generate-bytecode-expectations",
-      "unittests:unittests",
+      #"unittests:unittests",
     ]
   }
 }
@@ -86,7 +86,7 @@
     "mjsunit:v8_mjsunit",
     "mkgrokdump:mkgrokdump",
     "preparser:v8_preparser",
-    "unittests:unittests",
+    # "unittests:unittests",
     "wasm-spec-tests:v8_wasm_spec_tests",
     "webkit:v8_webkit",
   ]
@@ -105,7 +105,7 @@
     "mjsunit:v8_mjsunit",
     "mkgrokdump:mkgrokdump",
     "preparser:v8_preparser",
-    "unittests:unittests",
+    # "unittests:unittests",
     "wasm-spec-tests:v8_wasm_spec_tests",
   ]
 }
